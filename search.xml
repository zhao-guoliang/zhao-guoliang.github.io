<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>c++11条件变量</title>
      <link href="/2025/09/08/c-11%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/"/>
      <url>/2025/09/08/c-11%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>在 C++11 中，<code>std::condition_variable</code> 的 <code>wait</code> 方法用于使线程在某个条件满足之前等待，并自动释放和重新获得互斥量。下面详细解释 <code>cv.wait(lock, [] &#123; return ready; &#125;);</code> 这行代码的作用和工作原理：</p><h3 id="cv-wait-lock-return-ready-解释"><a href="#cv-wait-lock-return-ready-解释" class="headerlink" title="cv.wait(lock, [] { return ready; }); 解释"></a><code>cv.wait(lock, [] &#123; return ready; &#125;);</code> 解释</h3><ol><li><p><strong><code>cv.wait()</code> 方法</strong>:</p><ul><li><code>cv.wait()</code> 是 <code>std::condition_variable</code> 的一个成员函数，用于使线程等待，直到条件变量被通知，并且条件满足。</li><li>它接受两个参数：<ul><li>一个 <code>std::unique_lock&lt;std::mutex&gt;</code> 对象，用于与条件变量相关联的互斥量。</li><li>一个可调用对象（如 lambda 表达式、函数对象），用于检查条件是否满足。</li></ul></li></ul></li><li><p><strong>参数 <code>lock</code></strong>:</p><ul><li><code>lock</code> 是一个 <code>std::unique_lock&lt;std::mutex&gt;</code> 对象，表示在调用 <code>wait</code> 时持有的互斥量。</li><li><code>std::unique_lock</code> 提供了更灵活的锁管理功能，与 <code>std::mutex</code> 一起使用。</li></ul></li><li><p><strong>参数 <code>[] &#123; return ready; &#125;</code></strong>:</p><ul><li>这是一个 lambda 表达式，作为条件检查的函数。</li><li>它检查 <code>ready</code> 标志是否为 <code>true</code>。</li><li>如果 <code>ready</code> 为 <code>true</code>，表示条件满足，<code>wait</code> 方法将返回，线程继续执行。</li><li>如果 <code>ready</code> 为 <code>false</code>，线程将继续等待，直到条件变量被通知且条件满足。</li></ul></li></ol><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li><p><strong>进入 <code>wait</code></strong>:</p><ul><li>线程调用 <code>cv.wait(lock, [] &#123; return ready; &#125;);</code>，它会释放与 <code>lock</code> 相关联的互斥量，进入等待状态。</li><li>在等待期间，线程不会持有互斥量，允许其他线程修改 <code>ready</code> 标志或执行其他操作。</li></ul></li><li><p><strong>条件检查</strong>:</p><ul><li>在进入等待状态之前，线程会检查 <code>ready</code> 标志。</li><li>如果 <code>ready</code> 为 <code>true</code>，线程将不会进入等待状态，直接返回。</li><li>如果 <code>ready</code> 为 <code>false</code>，线程将进入等待状态，并等待条件变量的通知。</li></ul></li><li><p><strong>通知和重新获取锁</strong>:</p><ul><li>当其他线程改变条件并调用 <code>cv.notify_one()</code> 或 <code>cv.notify_all()</code> 时，条件变量会唤醒等待的线程。</li><li>被唤醒的线程会重新获得 <code>lock</code> 互斥量，并重新检查条件。</li><li>线程在重新获得锁后，执行 lambda 表达式检查条件是否满足。</li><li>如果条件满足，线程继续执行。如果条件不满足，线程将继续等待。</li></ul></li><li><p><strong>继续执行</strong>:</p><ul><li>一旦条件满足，线程将退出 <code>wait</code> 状态，重新获得互斥量，继续执行后续代码。</li></ul></li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面是一个使用条件变量的完整示例，其中 <code>cv.wait()</code> 用于等待生产者线程准备数据：</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span>std::queue&lt;<span class="hljs-type">int</span>&gt; data_queue;std::mutex mtx;std::condition_variable cv;<span class="hljs-type">bool</span> ready = <span class="hljs-literal">false</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">producer</span><span class="hljs-params">()</span> </span>&#123;    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 模拟生产过程</span>    &#123;        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;        data_queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// 放入数据</span>        ready = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记数据准备好了</span>    &#125;    cv.<span class="hljs-built_in">notify_one</span>(); <span class="hljs-comment">// 通知消费者线程</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;    cv.<span class="hljs-built_in">wait</span>(lock, [] &#123; <span class="hljs-keyword">return</span> ready; &#125;); <span class="hljs-comment">// 等待直到数据准备好</span>    <span class="hljs-type">int</span> data = data_queue.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 获取数据</span>    data_queue.<span class="hljs-built_in">pop</span>();    std::cout &lt;&lt; <span class="hljs-string">&quot;Consumed: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">std::thread <span class="hljs-title">prod</span><span class="hljs-params">(producer)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">cons</span><span class="hljs-params">(consumer)</span></span>;    prod.<span class="hljs-built_in">join</span>();    cons.<span class="hljs-built_in">join</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>cv.wait(lock, [] &#123; return ready; &#125;);</code> 是一种等待机制，线程会在 <code>ready</code> 条件满足之前挂起，直到条件变量被通知并条件满足后才会继续执行。</li><li>在等待期间，线程释放了互斥量，使得其他线程可以访问共享资源。</li><li><code>wait</code> 方法会自动重新获取互斥量，并在条件变量被通知后继续执行，确保数据的一致性和线程安全。</li></ul><p>在使用 <code>std::condition_variable</code> 时，<strong>检查条件值</strong>ready是非常重要的，尽管条件变量会通知等待的线程。但是，如果在等待期间不检查条件值，可能会导致逻辑错误或未定义的行为。</p><h3 id="为什么需要检查条件值"><a href="#为什么需要检查条件值" class="headerlink" title="为什么需要检查条件值"></a>为什么需要检查条件值</h3><ol><li><p><strong>虚假唤醒</strong>:</p><ul><li>条件变量的 <code>wait</code> 方法在某些情况下可能会发生虚假唤醒。虚假唤醒是指线程被唤醒时，条件变量没有实际满足预期条件。在这种情况下，线程必须重新检查条件是否真正满足。</li><li>如果不检查条件值，线程可能在条件未满足时继续执行，导致错误的程序行为。</li></ul></li><li><p><strong>避免竞争条件</strong>:</p><ul><li>条件变量与互斥量一起使用时，条件变量的通知可能发生在线程正在等待时。如果线程在通知发生时还没有完全释放互斥量，可能会出现竞争条件。</li><li>通过检查条件值，可以确保只有在条件真正满足时，线程才会继续执行，避免了可能的数据竞争问题。</li></ul></li><li><p><strong>代码正确性</strong>:</p><ul><li>在许多实际应用中，条件变量用于处理复杂的同步和协调任务。检查条件值可以确保线程按照预期的逻辑流程运行，避免由于条件不满足导致的错误。</li></ul></li></ol><h3 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h3><p>下面是一个没有检查条件值的例子，展示了为什么检查条件值是重要的：</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span>std::mutex mtx;std::condition_variable cv;<span class="hljs-type">bool</span> ready = <span class="hljs-literal">false</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">producer</span><span class="hljs-params">()</span> </span>&#123;    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 模拟生产过程</span>    &#123;        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;        ready = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记数据准备好了</span>    &#125;    cv.<span class="hljs-built_in">notify_one</span>(); <span class="hljs-comment">// 通知消费者线程</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;    cv.<span class="hljs-built_in">wait</span>(lock); <span class="hljs-comment">// 不检查条件值</span>    <span class="hljs-comment">// 由于没有检查条件值，线程可能在条件未满足时继续执行</span>    <span class="hljs-keyword">if</span> (ready) &#123;        std::cout &lt;&lt; <span class="hljs-string">&quot;Condition is met.&quot;</span> &lt;&lt; std::endl;    &#125; <span class="hljs-keyword">else</span> &#123;        std::cout &lt;&lt; <span class="hljs-string">&quot;Condition is not met.&quot;</span> &lt;&lt; std::endl;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">std::thread <span class="hljs-title">prod</span><span class="hljs-params">(producer)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">cons</span><span class="hljs-params">(consumer)</span></span>;    prod.<span class="hljs-built_in">join</span>();    cons.<span class="hljs-built_in">join</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>在上面的代码中，<code>cv.wait(lock)</code> 不检查条件值。尽管我们在生产者线程中设置了 <code>ready = true</code> 并通知了条件变量，但消费者线程在 <code>wait</code> 后可能会继续执行而没有检查条件值。这可能会导致错误输出或逻辑不一致。</p><h3 id="正确的做法"><a href="#正确的做法" class="headerlink" title="正确的做法"></a>正确的做法</h3><p>为了确保线程在条件满足时才继续执行，应使用 <code>wait</code> 方法的重载版本，它接受一个条件检查函数。例如：</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span>std::mutex mtx;std::condition_variable cv;<span class="hljs-type">bool</span> ready = <span class="hljs-literal">false</span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">producer</span><span class="hljs-params">()</span> </span>&#123;    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 模拟生产过程</span>    &#123;        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;        ready = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记数据准备好了</span>    &#125;    cv.<span class="hljs-built_in">notify_one</span>(); <span class="hljs-comment">// 通知消费者线程</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;    cv.<span class="hljs-built_in">wait</span>(lock, [] &#123; <span class="hljs-keyword">return</span> ready; &#125;); <span class="hljs-comment">// 检查条件值</span>    std::cout &lt;&lt; <span class="hljs-string">&quot;Condition is met.&quot;</span> &lt;&lt; std::endl;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">std::thread <span class="hljs-title">prod</span><span class="hljs-params">(producer)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">cons</span><span class="hljs-params">(consumer)</span></span>;    prod.<span class="hljs-built_in">join</span>();    cons.<span class="hljs-built_in">join</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>在这个例子中，<code>cv.wait(lock, [] &#123; return ready; &#125;);</code> 检查 <code>ready</code> 条件值，确保只有在条件真正满足时消费者线程才会继续执行。这样可以避免虚假唤醒和其他潜在的同步问题。</p><p>生产者-消费者模型是多线程编程中的经典问题，其主要任务是协调生产者线程和消费者线程，以便在生产和消费之间保持平衡。条件变量（<code>std::condition_variable</code>）是实现这一模型的一个重要工具，因为它提供了一种机制来协调和通知线程何时可以生产或消费数据。</p><h3 id="为什么使用条件变量"><a href="#为什么使用条件变量" class="headerlink" title="为什么使用条件变量"></a>为什么使用条件变量</h3><ol><li><p><strong>线程同步</strong>:</p><ul><li>条件变量可以用来同步生产者和消费者线程。当生产者线程产生新数据时，它可以通知消费者线程数据已准备好。当消费者线程处理完数据后，它可以通知生产者线程可以继续生产。条件变量帮助保证线程之间的正确同步和数据一致性。</li></ul></li><li><p><strong>避免忙等待</strong>:</p><ul><li>在没有条件变量的情况下，消费者线程可能会忙等待（不断检查是否有新数据）以决定是否继续执行。这会浪费 CPU 时间和资源，降低程序效率。使用条件变量可以使线程在没有数据可处理时挂起，直到有数据准备好为止，从而减少 CPU 使用率。</li></ul></li><li><p><strong>处理资源共享</strong>:</p><ul><li>条件变量与互斥量（<code>std::mutex</code>）一起使用，可以确保线程在访问共享资源（如缓冲区）时的安全性。在生产者线程将数据放入缓冲区时，它会锁定互斥量，并在放入数据后通知消费者线程。同样，消费者线程在获取数据前也会锁定互斥量，确保数据的正确性。</li></ul></li><li><p><strong>动态调整</strong>:</p><ul><li>条件变量允许生产者和消费者根据实际的生产和消费速度动态调整。这意味着生产者可以在缓冲区已满时暂停生产，而消费者可以在缓冲区为空时暂停消费。这样可以更灵活地适应不同的生产和消费速率。</li></ul></li></ol><h3 id="生产者-消费者模型示例"><a href="#生产者-消费者模型示例" class="headerlink" title="生产者-消费者模型示例"></a>生产者-消费者模型示例</h3><p>下面是一个使用条件变量的生产者-消费者示例，展示了如何使用条件变量来协调生产者和消费者线程：</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span>std::queue&lt;<span class="hljs-type">int</span>&gt; data_queue; <span class="hljs-comment">// 数据队列</span>std::mutex mtx; <span class="hljs-comment">// 互斥量</span>std::condition_variable cv; <span class="hljs-comment">// 条件变量</span><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> max_queue_size = <span class="hljs-number">10</span>; <span class="hljs-comment">// 最大队列大小</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">producer</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> data = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;        &#123;            <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;            cv.<span class="hljs-built_in">wait</span>(lock, [] &#123; <span class="hljs-keyword">return</span> data_queue.<span class="hljs-built_in">size</span>() &lt; max_queue_size; &#125;); <span class="hljs-comment">// 等待直到有空间</span>            data_queue.<span class="hljs-built_in">push</span>(data++); <span class="hljs-comment">// 生产数据</span>            std::cout &lt;&lt; <span class="hljs-string">&quot;Produced: &quot;</span> &lt;&lt; data - <span class="hljs-number">1</span> &lt;&lt; std::endl;        &#125;        cv.<span class="hljs-built_in">notify_all</span>(); <span class="hljs-comment">// 通知消费者线程</span>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">100</span>)); <span class="hljs-comment">// 模拟生产延迟</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;        <span class="hljs-type">int</span> data;        &#123;            <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;            cv.<span class="hljs-built_in">wait</span>(lock, [] &#123; <span class="hljs-keyword">return</span> !data_queue.<span class="hljs-built_in">empty</span>(); &#125;); <span class="hljs-comment">// 等待直到有数据</span>            data = data_queue.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 消费数据</span>            data_queue.<span class="hljs-built_in">pop</span>();            std::cout &lt;&lt; <span class="hljs-string">&quot;Consumed: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;        &#125;        cv.<span class="hljs-built_in">notify_all</span>(); <span class="hljs-comment">// 通知生产者线程</span>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">150</span>)); <span class="hljs-comment">// 模拟消费延迟</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">std::thread <span class="hljs-title">prod_thread</span><span class="hljs-params">(producer)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">cons_thread</span><span class="hljs-params">(consumer)</span></span>;    prod_thread.<span class="hljs-built_in">join</span>();    cons_thread.<span class="hljs-built_in">join</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><ol><li><p><strong>生产者线程</strong>:</p><ul><li>在生产者线程中，使用 <code>cv.wait()</code> 等待直到队列有空间可以添加新数据。</li><li>生产数据后，使用 <code>cv.notify_all()</code> 通知所有等待的消费者线程，表示数据已准备好。</li></ul></li><li><p><strong>消费者线程</strong>:</p><ul><li>在消费者线程中，使用 <code>cv.wait()</code> 等待直到队列中有数据可以消费。</li><li>消费数据后，使用 <code>cv.notify_all()</code> 通知所有等待的生产者线程，表示队列中有空位可以添加新数据。</li></ul></li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>条件变量是生产者-消费者模型中实现线程同步和协调的重要工具。它们通过提供一种机制来等待和通知线程，帮助有效地管理资源共享、避免忙等待，并允许线程根据实际情况动态调整生产和消费行为。通过合理使用条件变量，可以确保生产者和消费者线程之间的有效协作和程序的高效运行。</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/09/08/hello-world/"/>
      <url>/2025/09/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>QT——QSS界面风格分享</title>
      <link href="/2024/11/02/QT%E2%80%94%E2%80%94QSS%E7%95%8C%E9%9D%A2%E9%A3%8E%E6%A0%BC%E5%88%86%E4%BA%AB/"/>
      <url>/2024/11/02/QT%E2%80%94%E2%80%94QSS%E7%95%8C%E9%9D%A2%E9%A3%8E%E6%A0%BC%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>QT多线程</title>
      <link href="/2024/11/02/QT%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2024/11/02/QT%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>QT配置动态库静态库头文件</title>
      <link href="/2024/11/02/QT%E9%85%8D%E7%BD%AE%E5%8A%A8%E6%80%81%E5%BA%93%E9%9D%99%E6%80%81%E5%BA%93%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
      <url>/2024/11/02/QT%E9%85%8D%E7%BD%AE%E5%8A%A8%E6%80%81%E5%BA%93%E9%9D%99%E6%80%81%E5%BA%93%E5%A4%B4%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>QTest测试</title>
      <link href="/2024/11/02/QTest%E6%B5%8B%E8%AF%95/"/>
      <url>/2024/11/02/QTest%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Visualstudio打开qt界面闪退</title>
      <link href="/2024/11/02/Visualstudio%E6%89%93%E5%BC%80qt%E7%95%8C%E9%9D%A2%E9%97%AA%E9%80%80/"/>
      <url>/2024/11/02/Visualstudio%E6%89%93%E5%BC%80qt%E7%95%8C%E9%9D%A2%E9%97%AA%E9%80%80/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>QT程序打包</title>
      <link href="/2024/11/02/QT%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85/"/>
      <url>/2024/11/02/QT%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>QT中文乱码</title>
      <link href="/2024/11/02/QT%E7%95%8C%E9%9D%A2%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
      <url>/2024/11/02/QT%E7%95%8C%E9%9D%A2%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>问题：</p><p>QT程序界面显示中文乱码。</p><p>解决方法：</p><p>在文件开始位置，包含头文件位置，增加：<code>#pragma execution_character_set(&quot;utf-8&quot;)</code></p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;widget.h&quot;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;QApplication&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> execution_character_set(<span class="hljs-string">&quot;utf-8&quot;</span>)</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">QApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;    Widget w;    w.<span class="hljs-built_in">setWindowTitle</span>(<span class="hljs-string">&quot;一个窗口&quot;</span>);    w.<span class="hljs-built_in">show</span>();    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">exec</span>();&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>。。。</title>
      <link href="/2024/08/22/%E3%80%82%E3%80%82%E3%80%82/"/>
      <url>/2024/08/22/%E3%80%82%E3%80%82%E3%80%82/</url>
      
        <content type="html"><![CDATA[<pre><code class="hljs c++"><span class="hljs-comment">// 链表原地逆置</span><span class="hljs-function">ListNode* <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;        <span class="hljs-comment">// 方法1</span>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> == head) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;        &#125;        <span class="hljs-comment">// 链表原地逆置</span>        ListNode *newHead = <span class="hljs-literal">nullptr</span>;        ListNode *tempNode = <span class="hljs-literal">nullptr</span>;        <span class="hljs-keyword">while</span> (<span class="hljs-literal">nullptr</span> != head) &#123;            tempNode = head-&gt;next;            head-&gt;next = newHead;            newHead = head;            head = tempNode;        &#125;        <span class="hljs-keyword">return</span> newHead;    &#125;</code></pre><pre><code class="hljs c++"><span class="hljs-comment">//递归合并两个有序链表</span><span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoSortedLists</span><span class="hljs-params">(ListNode* L1, ListNode* L2)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (L1 == <span class="hljs-literal">nullptr</span>)        <span class="hljs-keyword">return</span> L2;    <span class="hljs-keyword">if</span> (L2 == <span class="hljs-literal">nullptr</span>)        <span class="hljs-keyword">return</span> L1;    <span class="hljs-keyword">if</span> (L1-&gt;val &lt;= L2-&gt;val)    &#123;        L1-&gt;next = <span class="hljs-built_in">mergeTwoSortedLists</span>(L1-&gt;next, L2);        <span class="hljs-keyword">return</span> L1;    &#125;    <span class="hljs-keyword">else</span>    &#123;        L2-&gt;next = <span class="hljs-built_in">mergeTwoSortedLists</span>(L1, L2-&gt;next);        <span class="hljs-keyword">return</span> L2;    &#125;&#125;</code></pre><pre><code class="hljs c++"><span class="hljs-comment">// 优先队列 priority_queue</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Compare</span> &#123;    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> ListNode* lhs, <span class="hljs-type">const</span> ListNode* rhs)</span> <span class="hljs-type">const</span> </span>&#123;        <span class="hljs-keyword">return</span> lhs-&gt;val &gt; rhs-&gt;val;<span class="hljs-comment">//小根堆</span>    &#125;&#125;;<span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;    priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;,Compare&gt; q;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> l : lists)&#123;        <span class="hljs-keyword">if</span>(l != <span class="hljs-literal">nullptr</span>)&#123;            q.<span class="hljs-built_in">push</span>(l);        &#125;    &#125;    ListNode* newHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);    ListNode* cur = newHead;    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;        cur-&gt;next = q.<span class="hljs-built_in">top</span>();        q.<span class="hljs-built_in">pop</span>();        cur = cur-&gt;next;        <span class="hljs-keyword">if</span>(cur-&gt;next)&#123;            q.<span class="hljs-built_in">push</span>(cur-&gt;next);        &#125;    &#125;    <span class="hljs-keyword">return</span> newHead-&gt;next;&#125;</code></pre><pre><code class="hljs c++"><span class="hljs-comment">// 链表有没有环</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;        ListNode* fast = head;        ListNode* slow = head;        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;            fast = fast-&gt;next-&gt;next;            slow = slow-&gt;next;            <span class="hljs-keyword">if</span>(fast == slow)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;</code></pre><pre><code class="hljs c++"><span class="hljs-comment">// 找到有环链表的入口节点</span><span class="hljs-function">ListNode* <span class="hljs-title">EntryNodeOfLoop</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;    <span class="hljs-comment">// 方法一</span>    set&lt;ListNode*&gt; s;    ListNode* cur = pHead;    <span class="hljs-keyword">while</span> (cur!= <span class="hljs-literal">nullptr</span>) &#123;        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">count</span>(cur))&#123;            <span class="hljs-keyword">return</span> cur;        &#125;        s.<span class="hljs-built_in">insert</span>(cur);        cur = cur-&gt;next;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">struct ListNode &#123;</span><span class="hljs-comment">    int val;</span><span class="hljs-comment">    struct ListNode *next;</span><span class="hljs-comment">    ListNode(int x) :</span><span class="hljs-comment">        val(x), next(NULL) &#123;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">&#125;;</span><span class="hljs-comment">*/</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">ListNode* <span class="hljs-title">EntryNodeOfLoop</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;        <span class="hljs-comment">// 方法二</span>        ListNode* fast = pHead;        ListNode* slow = pHead;        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<span class="hljs-comment">// 判断有没有环</span>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;            fast = fast-&gt;next-&gt;next;            slow = slow-&gt;next;            <span class="hljs-keyword">if</span>(fast == slow)&#123;                flag = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(flag)&#123;            <span class="hljs-comment">// 有环  接着计算环的长度</span>            fast = fast-&gt;next;            <span class="hljs-type">int</span> n = <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span> (slow != fast) &#123;                fast = fast-&gt;next;                n++;            &#125;                        <span class="hljs-comment">//两个指针指向头部， 先让一个指针走 一个环的距离， 等两个指针再次相遇的时候， 就是环的入口点。</span>            slow = fast = pHead;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++) &#123;                fast = fast-&gt;next;            &#125;            <span class="hljs-keyword">while</span> (slow != fast) &#123;                slow = slow-&gt;next;                fast = fast-&gt;next;            &#125;            <span class="hljs-keyword">return</span> slow;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;    &#125;&#125;;</code></pre><pre><code class="hljs c++"><span class="hljs-comment">// 二分查找</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;    <span class="hljs-comment">// write code here</span>    <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> r = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;    <span class="hljs-type">int</span> m = <span class="hljs-number">-1</span>;    <span class="hljs-keyword">while</span> (l&lt;=r) &#123;        m = (l+r)/<span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span>(nums[m]==target)&#123;            <span class="hljs-keyword">return</span> m;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[m]&gt;target)&#123;            r = m<span class="hljs-number">-1</span>;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[m]&lt;target)&#123;            l = m<span class="hljs-number">+1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;</code></pre><pre><code class="hljs c++"><span class="hljs-comment">// 两个链表的第一个公共节点</span><span class="hljs-function">ListNode* <span class="hljs-title">FindFirstCommonNode</span><span class="hljs-params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;        <span class="hljs-comment">// 方法er</span>ListNode* l1 = pHead1;ListNode* l2 = pHead2;<span class="hljs-keyword">while</span> (l1 != l2) &#123;l1 = (l1==<span class="hljs-literal">nullptr</span>)?pHead2:l1-&gt;next;l2 = (l2==<span class="hljs-literal">nullptr</span>)?pHead1:l2-&gt;next;&#125;<span class="hljs-keyword">return</span> l1;<span class="hljs-comment">// 方法一</span><span class="hljs-comment">/*</span><span class="hljs-comment">set&lt;ListNode*&gt; s;</span><span class="hljs-comment">while (pHead1 != nullptr) &#123;</span><span class="hljs-comment">s.insert(pHead1);</span><span class="hljs-comment">pHead1 = pHead1-&gt;next;</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">while (pHead2 != nullptr) &#123;</span><span class="hljs-comment">if(s.count(pHead2))&#123;</span><span class="hljs-comment">return pHead2;</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">pHead2 = pHead2-&gt;next;</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">return nullptr;</span><span class="hljs-comment">*/</span>    &#125;</code></pre><pre><code class="hljs c++"><span class="hljs-comment">// 两个stack模拟queue</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span> </span>&#123;        stack<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(node);    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (stack<span class="hljs-number">2.</span><span class="hljs-built_in">empty</span>()) &#123;            <span class="hljs-keyword">while</span> (!stack<span class="hljs-number">1.</span><span class="hljs-built_in">empty</span>()) &#123;                stack<span class="hljs-number">2.</span><span class="hljs-built_in">push</span>(stack<span class="hljs-number">1.</span><span class="hljs-built_in">top</span>());                stack<span class="hljs-number">1.</span><span class="hljs-built_in">pop</span>();            &#125;        &#125;        <span class="hljs-type">int</span> val = stack<span class="hljs-number">2.</span><span class="hljs-built_in">top</span>();        stack<span class="hljs-number">2.</span><span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">return</span> val;    &#125;<span class="hljs-keyword">private</span>:    stack&lt;<span class="hljs-type">int</span>&gt; stack1;    stack&lt;<span class="hljs-type">int</span>&gt; stack2;&#125;;</code></pre><pre><code class="hljs cpp"><span class="hljs-comment">// 最长公共前缀</span><span class="hljs-function">string <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;        <span class="hljs-comment">// write code here</span>                <span class="hljs-type">int</span> n = strs.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span> || n==<span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> n==<span class="hljs-number">0</span>?<span class="hljs-string">&quot;&quot;</span>:strs[<span class="hljs-number">0</span>];        &#125;              <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-number">1</span>; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j&lt;n<span class="hljs-number">-1</span>; j++) &#123;                <span class="hljs-keyword">if</span>(strs[j][i] != strs[j<span class="hljs-number">+1</span>][i])&#123;                    <span class="hljs-keyword">return</span> strs[j].<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,i);                &#125;            &#125;        &#125;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>lambda表达式</title>
      <link href="/2024/08/21/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2024/08/21/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>lambda表达式是C++11最重要也是最常用的特性之一，这是现代编程语言的一个特点，lambda表达式有如下的一些优点：</p><ul><li>声明式的编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或函数对象。</li><li>简洁：避免了代码膨胀和功能分散，让开发更加高效。</li><li>在需要的时间和地点实现功能闭包，使程序更加灵活。</li></ul><p>lambda表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。lambda表达式的语法形式简单归纳如下：<br><code>[capture](params) opt -&gt; ret &#123;body;&#125;;</code><br>其中capture是捕获列表，params是参数列表，opt是函数选项，ret是返回值类型，body是函数体。</p><ul><li><p>捕获列表[]: 捕获一定范围内的变量</p></li><li><p>参数列表(): 和普通函数的参数列表一样，如果没有参数参数列表可以省略不写。</p><p><code>auto f = []()&#123;return 1;&#125;    // 没有参数, 参数列表为空</code><br><code>auto f = []&#123;return 1;&#125;        // 没有参数, 参数列表省略不写</code></p></li><li><p>opt 选项， 不需要可以省略</p><p>mutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）<br>exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用throw();</p></li><li><p>返回值类型：在C++11中，lambda表达式的返回值是通过返回值后置语法来定义的。</p></li><li><p>函数体：函数的实现，这部分不能省略，但函数体可以为空。</p></li></ul><h3 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h3><p>lambda表达式的捕获列表可以捕获一定范围内的变量，具体使用方式如下：</p><p>[] - 不捕捉任何变量<br>[&amp;] - 捕获外部作用域中所有变量, 并作为引用在函数体内使用 (按引用捕获)<br>[&#x3D;] - 捕获外部作用域中所有变量, 并作为副本在函数体内使用 (按值捕获)<br>拷贝的副本在匿名函数体内部是只读的<br>[&#x3D;, &amp;foo] - 按值捕获外部作用域中所有变量, 并按照引用捕获外部变量 foo<br>[bar] - 按值捕获 bar 变量, 同时不捕获其他变量<br>[&amp;bar] - 按引用捕获 bar 变量, 同时不捕获其他变量<br>[this] - 捕获当前类中的this指针<br>让lambda表达式拥有和当前类成员函数同样的访问权限<br>如果已经使用了 &amp; 或者 &#x3D;, 默认添加此选项<br>下面通过一个例子，看一下初始化列表的具体用法：</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">auto</span> x1 = [] &#123;<span class="hljs-keyword">return</span> m_number; &#125;;                      <span class="hljs-comment">// error</span>        <span class="hljs-keyword">auto</span> x2 = [=] &#123;<span class="hljs-keyword">return</span> m_number + x + y; &#125;;             <span class="hljs-comment">// ok</span>        <span class="hljs-keyword">auto</span> x3 = [&amp;] &#123;<span class="hljs-keyword">return</span> m_number + x + y; &#125;;             <span class="hljs-comment">// ok</span>        <span class="hljs-keyword">auto</span> x4 = [<span class="hljs-keyword">this</span>] &#123;<span class="hljs-keyword">return</span> m_number; &#125;;                  <span class="hljs-comment">// ok</span>        <span class="hljs-keyword">auto</span> x5 = [<span class="hljs-keyword">this</span>] &#123;<span class="hljs-keyword">return</span> m_number + x + y; &#125;;          <span class="hljs-comment">// error</span>        <span class="hljs-keyword">auto</span> x6 = [<span class="hljs-keyword">this</span>, x, y] &#123;<span class="hljs-keyword">return</span> m_number + x + y; &#125;;    <span class="hljs-comment">// ok</span>        <span class="hljs-keyword">auto</span> x7 = [<span class="hljs-keyword">this</span>] &#123;<span class="hljs-keyword">return</span> m_number++; &#125;;                <span class="hljs-comment">// ok</span>    &#125;    <span class="hljs-type">int</span> m_number = <span class="hljs-number">100</span>;&#125;;</code></pre><p>x1：错误，没有捕获外部变量，不能使用类成员 m_number<br>x2：正确，以值拷贝的方式捕获所有外部变量<br>x3：正确，以引用的方式捕获所有外部变量<br>x4：正确，捕获this指针，可访问对象内部成员<br>x5：错误，捕获this指针，可访问类内部成员，没有捕获到变量x，y，因此不能访问。<br>x6：正确，捕获this指针，x，y<br>x7：正确，捕获this指针，并且可以修改对象内部变量的值</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;    <span class="hljs-keyword">auto</span> f1 = [] &#123;<span class="hljs-keyword">return</span> a; &#125;;                        <span class="hljs-comment">// error</span>    <span class="hljs-keyword">auto</span> f2 = [&amp;] &#123;<span class="hljs-keyword">return</span> a++; &#125;;                     <span class="hljs-comment">// ok</span>    <span class="hljs-keyword">auto</span> f3 = [=] &#123;<span class="hljs-keyword">return</span> a; &#125;;                       <span class="hljs-comment">// ok</span>    <span class="hljs-keyword">auto</span> f4 = [=] &#123;<span class="hljs-keyword">return</span> a++; &#125;;                     <span class="hljs-comment">// error</span>    <span class="hljs-keyword">auto</span> f5 = [a] &#123;<span class="hljs-keyword">return</span> a + b; &#125;;                   <span class="hljs-comment">// error</span>    <span class="hljs-keyword">auto</span> f6 = [a, &amp;b] &#123;<span class="hljs-keyword">return</span> a + (b++); &#125;;           <span class="hljs-comment">// ok</span>    <span class="hljs-keyword">auto</span> f7 = [=, &amp;b] &#123;<span class="hljs-keyword">return</span> a + (b++); &#125;;           <span class="hljs-comment">// ok</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>f1：错误，没有捕获外部变量，因此无法访问变量 a<br>f2：正确，使用引用的方式捕获外部变量，可读写<br>f3：正确，使用值拷贝的方式捕获外部变量，可读<br>f4：错误，使用值拷贝的方式捕获外部变量，可读不能写<br>f5：错误，使用拷贝的方式捕获了外部变量a，没有捕获外部变量b，因此无法访问变量b<br>f6：正确，使用拷贝的方式捕获了外部变量a，只读，使用引用的方式捕获外部变量b，可读写<br>f7：正确，使用值拷贝的方式捕获所有外部变量以及b的引用，b可读写，其他只读<br>在匿名函数内部，需要通过lambda表达式的捕获列表控制如何捕获外部变量，以及访问哪些变量。默认状态下lambda表达式无法修改通过复制方式捕获外部变量，如果希望修改这些外部变量，需要通过引用的方式进行捕获。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>很多时候，lambda表达式的返回值是非常明显的，因此在C++11中允许省略lambda表达式的返回值。</p><pre><code class="hljs cpp"><span class="hljs-comment">// 完整的lambda表达式定义</span><span class="hljs-keyword">auto</span> f = [](<span class="hljs-type">int</span> a) -&gt; <span class="hljs-type">int</span>&#123;    <span class="hljs-keyword">return</span> a<span class="hljs-number">+10</span>;  &#125;;<span class="hljs-comment">// 忽略返回值的lambda表达式定义</span><span class="hljs-keyword">auto</span> f = [](<span class="hljs-type">int</span> a)&#123;    <span class="hljs-keyword">return</span> a<span class="hljs-number">+10</span>;  &#125;;<span class="hljs-comment">/*</span><span class="hljs-comment">一般情况下，不指定lambda表达式的返回值，编译器会根据return语句自动推导返回值的类型，但需要注意的是labmda表达式不能通过列表初始化自动推导出返回值类型。</span><span class="hljs-comment">*/</span><span class="hljs-comment">// ok，可以自动推导出返回值类型</span><span class="hljs-keyword">auto</span> f = [](<span class="hljs-type">int</span> i)&#123;    <span class="hljs-keyword">return</span> i;&#125;<span class="hljs-comment">// error，不能推导出返回值类型</span><span class="hljs-keyword">auto</span> f1 = []()&#123;    <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<span class="hljs-comment">// 基于列表初始化推导返回值，错误</span>&#125;</code></pre><h3 id="函数本质"><a href="#函数本质" class="headerlink" title="函数本质"></a>函数本质</h3><p>使用lambda表达式捕获列表捕获外部变量，如果希望去修改按值捕获的外部变量，那么应该如何处理呢？这就需要使用mutable选项，被mutable修改是lambda表达式就算没有参数也要写明参数列表，并且可以去掉按值捕获的外部变量的只读（const）属性。</p><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<span class="hljs-keyword">auto</span> f1 = [=] &#123;<span class="hljs-keyword">return</span> a++; &#125;;              <span class="hljs-comment">// error, 按值捕获外部变量, a是只读的</span><span class="hljs-keyword">auto</span> f2 = [=]()<span class="hljs-keyword">mutable</span> &#123;<span class="hljs-keyword">return</span> a++; &#125;;     <span class="hljs-comment">// ok</span></code></pre><p>最后再剖析一下为什么通过值拷贝的方式捕获的外部变量是只读的:</p><p>lambda表达式的类型在C++11中会被看做是一个带operator()的类，即仿函数。<br>按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量值的。<br>mutable选项的作用就在于取消operator()的const属性。</p><p>因为lambda表达式在C++中会被看做是一个仿函数，因此可以使用std::function和std::bind来存储和操作lambda表达式：</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// 包装可调用函数</span>    std::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; f1 = [](<span class="hljs-type">int</span> a) &#123;<span class="hljs-keyword">return</span> a; &#125;;    <span class="hljs-comment">// 绑定可调用函数</span>    std::function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; f2 = <span class="hljs-built_in">bind</span>([](<span class="hljs-type">int</span> a) &#123;<span class="hljs-keyword">return</span> a; &#125;, placeholders::_1);    <span class="hljs-comment">// 函数调用</span>    cout &lt;&lt; <span class="hljs-built_in">f1</span>(<span class="hljs-number">100</span>) &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-built_in">f2</span>(<span class="hljs-number">200</span>) &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>对于没有捕获任何变量的lambda表达式，还可以转换成一个普通的函数指针：</p><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> func_ptr = <span class="hljs-built_in">int</span>(*)(<span class="hljs-type">int</span>);<span class="hljs-comment">// 没有捕获任何外部变量的匿名函数</span>func_ptr f = [](<span class="hljs-type">int</span> a)&#123;    <span class="hljs-keyword">return</span> a;  &#125;;<span class="hljs-comment">// 函数调用</span><span class="hljs-built_in">f</span>(<span class="hljs-number">1314</span>);</code></pre><p>链接: <a href="https://subingwen.cn/cpp/lambda/#4-%E5%87%BD%E6%95%B0%E6%9C%AC%E8%B4%A8">https://subingwen.cn/cpp/lambda/#4-%E5%87%BD%E6%95%B0%E6%9C%AC%E8%B4%A8</a><br>来源: 爱编程的大丙</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pthread_rwlock_t未定义问题</title>
      <link href="/2024/08/17/pthread-rwlock-t%E6%9C%AA%E5%AE%9A%E4%B9%89%E9%97%AE%E9%A2%98/"/>
      <url>/2024/08/17/pthread-rwlock-t%E6%9C%AA%E5%AE%9A%E4%B9%89%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>最近在linux上次编译时出现pthread_rwlock_t没有定义的现象.但是已经include了pthread.h,网上查了一些资料后发现,原因竟然是因为显示使用了-std&#x3D;c99参数导致.</p><p>在c99没有完全实现时,如果不显示指定-std, 则gcc默认使用gnu89(或gnu90)标准.</p><p>一般而言,</p><p>​        <strong>gnuXX标准 &#x3D; cXX标准 + GNU extension</strong></p><p><em>而pthread_rwlock_t正好就是GNU extension的一部分. 所以指定使用c99就会把GNU extension禁用,造成pthread_rwlock_t未定义的问题.</em></p><p>解决方法:</p><p>方法一: 把-std&#x3D;c99去掉,</p><p>方法二: 或者改成-std&#x3D;gnu89, -std&#x3D;gnu90, -std&#x3D;gnu99 这类</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C100</title>
      <link href="/2024/08/17/C-100/"/>
      <url>/2024/08/17/C-100/</url>
      
        <content type="html"><![CDATA[<ol><li>请填写bool , float,  指针变量 与“零值”比较的if语句。</li></ol><pre><code class="hljs c"><span class="hljs-keyword">if</span>(flag); <span class="hljs-keyword">if</span>(!flag);<span class="hljs-type">const</span> <span class="hljs-type">float</span> EPSINON = <span class="hljs-number">0.00001</span>;<span class="hljs-keyword">if</span> ((x &gt;= - EPSINON) &amp;&amp; (x &lt;= EPSINON))<span class="hljs-comment">// 详解：不可将浮点变量用“ == ” 或“！=” 与数字比较，应该设法转化成“&gt;=” 或“&lt;=” 此类形式。</span>    <span class="hljs-keyword">if</span>(p= =<span class="hljs-literal">NULL</span>) ; <span class="hljs-keyword">if</span>(p!=<span class="hljs-literal">NULL</span>)</code></pre><p>解释：</p><p>直接判断浮点数是否等于零的问题在于，浮点数的计算存在舍入误差。在计算机中，浮点数的运算并不是完全精确的，特别是在涉及除法、乘法等复杂运算时，可能会产生很小的误差。这些误差可能导致原本应该相等的数字变得不完全相等，尽管它们看起来很接近。</p><p>例如，考虑以下代码：</p><pre><code class="hljs c"><span class="hljs-type">float</span> x = <span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, x);  <span class="hljs-comment">// 输出 &quot;0.300000&quot;，但实际上 x 可能不是精确的 0.3</span></code></pre><p>虽然看起来 <code>x</code> 应该等于 <code>0.3</code>，但在某些系统上，由于浮点数的舍入误差，<code>x</code> 可能并不严格等于 <code>0.3</code>。如果我们直接比较 <code>x == 0.3</code>，可能会得到 false，即使 <code>x</code> 很接近 <code>0.3</code>。</p><p>为了避免这种情况，我们需要引入一个较小的阈值（如 <code>EPSILON</code>）来判断浮点数是否足够接近于零或其他特定值。这种方法称为“模糊比较”或“容限比较”。通过这种方式，我们可以接受一定范围内的误差，而不是要求绝对精确匹配。</p><p>在你的例子中，<code>if ((x &gt;= -EPSILON) &amp;&amp; (x &lt;= EPSILON))</code> 将会捕获那些实际上非常接近于零但不完全等于零的浮点数。这样，即使存在舍入误差，也能正确地判断出 <code>x</code> 是否可以视为零。</p><ol start="2"><li>以下为Linux下的32 位C 程序，请计算sizeof 的值。</li></ol><pre><code class="hljs c"><span class="hljs-type">char</span>  str[] = “Hello” ;  <span class="hljs-type">char</span>  *p = str ;                                      <span class="hljs-type">int</span>   n = <span class="hljs-number">10</span>;                                               <span class="hljs-comment">//请计算</span>（<span class="hljs-number">1</span>）<span class="hljs-keyword">sizeof</span> ( str ) =  <span class="hljs-number">6</span>                （<span class="hljs-number">2</span>）<span class="hljs-keyword">sizeof</span> ( p ) =  <span class="hljs-number">4</span>               （<span class="hljs-number">3</span>）<span class="hljs-keyword">sizeof</span> ( n ) = <span class="hljs-number">4</span>（<span class="hljs-number">4</span>）<span class="hljs-type">void</span> Func ( <span class="hljs-type">char</span> str[<span class="hljs-number">100</span>])                           &#123;                                          …… ;           请计算<span class="hljs-keyword">sizeof</span>( str ) = <span class="hljs-number">4</span>&#125;                                           （<span class="hljs-number">5</span>）<span class="hljs-type">void</span> *p=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<span class="hljs-keyword">sizeof</span>( p )= <span class="hljs-number">4</span></code></pre><p><strong>解释</strong>：</p><p><code>sizeof</code> 是 C++ 中的一个运算符，用于计算对象或类型所占的内存大小，单位为字节（<code>byte</code>）。当 <code>sizeof</code> 运算符用于字符串时，不同场景下的结果会有所不同。以下是对 <code>sizeof</code> 在不同情况下计算字符串大小的详解。</p><h3 id="sizeof-对字符串字面量的计算"><a href="#sizeof-对字符串字面量的计算" class="headerlink" title="sizeof 对字符串字面量的计算"></a><strong><code>sizeof</code> 对字符串字面量的计算</strong></h3><p>字符串字面量在 C++ 中是以 <code>const char[]</code> 数组的形式存在的，并且以 <code>&#39;\0&#39;</code>（空字符）作为结束符。因此，<code>sizeof</code> 对字符串字面量的计算结果包含字符串中的所有字符以及结尾的 <code>&#39;\0&#39;</code> 字符。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;Hello, world!&quot;</span>;    std::cout &lt;&lt; <span class="hljs-string">&quot;sizeof(str) = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(str) &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">&quot;sizeof(\&quot;Hello, world!\&quot;) = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>) &lt;&lt; std::endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>输出结果：</strong></p><pre><code class="hljs plaintext">sizeof(str) = 8        // 在 64 位系统中，指针的大小为 8 字节sizeof(&quot;Hello, world!&quot;) = 14 // 字符串字面量的大小，包括 &#x27;\0&#x27; 字符</code></pre><p><strong>分析：</strong></p><ul><li><code>sizeof(str)</code>：<code>str</code> 是一个指向 <code>const char</code> 的指针，因此 <code>sizeof(str)</code> 计算的是指针的大小。在 64 位系统中，指针通常占用 8 字节，在 32 位系统中占用 4 字节。</li><li><code>sizeof(&quot;Hello, world!&quot;)</code>：<code>&quot;Hello, world!&quot;</code> 是一个字符串字面量，它占用的大小包括所有字符和结尾的 <code>&#39;\0&#39;</code>，所以是 14 字节。</li></ul><h3 id="sizeof-对-char-数组的计算"><a href="#sizeof-对-char-数组的计算" class="headerlink" title="sizeof 对 char 数组的计算"></a><strong><code>sizeof</code> 对 <code>char</code> 数组的计算</strong></h3><p>当 <code>sizeof</code> 用于 <code>char</code> 数组时，它返回整个数组的大小。注意，这与字符串的实际长度（不包括 <code>&#39;\0&#39;</code>）不同，<code>sizeof</code> 返回的是数组占用的总字节数。</p><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;Hello&quot;</span>;    <span class="hljs-type">char</span> str2[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;Hi&quot;</span>;    std::cout &lt;&lt; <span class="hljs-string">&quot;sizeof(str1) = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(str1) &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">&quot;sizeof(str2) = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(str2) &lt;&lt; std::endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>输出结果：</strong></p><pre><code class="hljs plaintext">sizeof(str1) = 6 // &quot;Hello&quot; + &#x27;\0&#x27; = 6 字节sizeof(str2) = 10 // str2 数组的大小是 10 字节，不管实际存储的内容是什么</code></pre><p><strong>分析：</strong></p><ul><li><code>sizeof(str1)</code>：<code>str1</code> 是一个包含 6 个字符的 <code>char</code> 数组（包括末尾的 <code>&#39;\0&#39;</code>），所以 <code>sizeof(str1)</code> 返回 6。</li><li><code>sizeof(str2)</code>：<code>str2</code> 是一个大小为 10 的 <code>char</code> 数组，尽管它只存储了 <code>&quot;Hi&quot;</code> 和 <code>&#39;\0&#39;</code>，但是 <code>sizeof(str2)</code> 返回数组的总大小，即 10。</li></ul><h3 id="sizeof-对-std-string-的计算"><a href="#sizeof-对-std-string-的计算" class="headerlink" title="sizeof 对 std::string 的计算"></a><strong><code>sizeof</code> 对 <code>std::string</code> 的计算</strong></h3><p><code>std::string</code> 是 C++ 标准库中的字符串类，<code>sizeof</code> 返回的是 <code>std::string</code> 对象的大小，而不是字符串数据本身的大小。<code>std::string</code> 通常包含一个指向动态分配内存的指针（用来存储字符串内容）、字符串长度、容量等信息。</p><h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    std::string str = <span class="hljs-string">&quot;Hello, world!&quot;</span>;    std::cout &lt;&lt; <span class="hljs-string">&quot;sizeof(str) = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(str) &lt;&lt; std::endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>输出结果：</strong></p><pre><code class="hljs plaintext">sizeof(str) = 32 // 具体大小可能依赖于实现和系统架构</code></pre><p><strong>分析：</strong></p><ul><li><code>sizeof(str)</code>：返回的是 <code>std::string</code> 对象的大小，这个大小包含了管理字符串所需的元数据（如指针、长度、容量等），而不是字符串数据本身的大小。实际的大小可能因编译器和标准库实现的不同而有所变化。</li></ul><h3 id="strlen-和-sizeof-的区别"><a href="#strlen-和-sizeof-的区别" class="headerlink" title="strlen 和 sizeof 的区别"></a><strong><code>strlen</code> 和 <code>sizeof</code> 的区别</strong></h3><p><code>strlen</code> 和 <code>sizeof</code> 经常一起讨论，因为它们都涉及字符串的大小，但作用不同：</p><ul><li><p><strong><code>sizeof</code></strong>：在编译时确定，用于获取对象或类型所占的字节数。对于数组，它返回整个数组的大小；对于指针，它返回指针的大小；对于字符串字面量，它包括 <code>&#39;\0&#39;</code> 的大小。</p></li><li><p><strong><code>strlen</code></strong>：在运行时确定，用于计算以 <code>&#39;\0&#39;</code> 结束的字符串的长度，不包括 <code>&#39;\0&#39;</code>。</p></li></ul><p><strong>示例：</strong></p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;Hello, world!&quot;</span>;    std::cout &lt;&lt; <span class="hljs-string">&quot;sizeof(str) = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(str) &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">&quot;strlen(str) = &quot;</span> &lt;&lt; <span class="hljs-built_in">strlen</span>(str) &lt;&lt; std::endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>输出结果：</strong></p><pre><code class="hljs plaintext">sizeof(str) = 14 // &quot;Hello, world!&quot; + &#x27;\0&#x27;strlen(str) = 13 // &quot;Hello, world!&quot; 不包括 &#x27;\0&#x27;</code></pre><p><strong>分析：</strong></p><ul><li><code>sizeof(str)</code> 返回的是整个数组的大小，包括字符串字面量中的 <code>&#39;\0&#39;</code>。</li><li><code>strlen(str)</code> 返回的是字符串的长度，不包括 <code>&#39;\0&#39;</code>。</li></ul><p><strong>总结</strong></p><ul><li><p><code>sizeof</code> 在不同上下文下对字符串的计算结果会有所不同。对于字符串字面量，<code>sizeof</code> 包含 <code>&#39;\0&#39;</code> 的大小；对于指针，它返回指针的大小；对于 <code>std::string</code>，它返回对象的大小，而不是字符串数据的大小。</p></li><li><p><code>strlen</code> 则用于在运行时计算字符串的长度，不包括 <code>&#39;\0&#39;</code>。</p></li><li><p>理解 <code>sizeof</code> 和 <code>strlen</code> 的区别对编写高效、正确的 C++ 程序非常重要。</p><pre><code class="hljs c"> <span class="hljs-number">1.</span> 数组名和指针的区别数组名：在表达式中，数组名代表的是数组的首地址（即数组第一个元素的地址）。但它不仅仅是一个指针，它还包含数组的类型和大小信息。`<span class="hljs-keyword">sizeof</span>` 运算符能够获取数组的实际大小，因为编译器知道数组的确切类型和长度。指针：指针只是一个变量，用于存储地址。指针的大小通常是固定的（在 <span class="hljs-number">64</span> 位系统中为 <span class="hljs-number">8</span> 字节，在 <span class="hljs-number">32</span> 位系统中为 <span class="hljs-number">4</span> 字节），它并不包含任何关于所指向的内存块大小的信息。<span class="hljs-number">2.</span> 为什么 <span class="hljs-keyword">sizeof</span>(数组名) 返回的是数组的大小**当我们对数组名使用 <span class="hljs-keyword">sizeof</span> 时，编译器会返回整个数组所占的内存大小，而不是数组名（首地址）的大小。这是因为：- 数组名本质上并不是一个指针，而是一个表示整个数组的符号。- 编译器在编译时知道数组的确切大小，因此 `<span class="hljs-keyword">sizeof</span>` 可以返回整个数组的大小，而不仅仅是一个指针的大小。<span class="hljs-number">3.</span> 数组名作为指针使用的情况虽然数组名不是一个普通的指针，但在某些情况下（例如传递给函数时），它会退化为指针。这是因为在 C/C++ 中，当数组名被用作函数参数时，它会自动退化为指向数组首元素的指针。</code></pre></li></ul><ol start="3"><li><p>用变量a 给出下面的定义<br>e) 一个有10个指针的数组，该指针是指向一个整型数的;<br>f)  一个指向有10个整型数数组的指针;<br>g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数;<br>h) 一个有10个指针的数组，每个指针指向一个函数，该函数有一个整型参数并返回一个整型数;</p><pre><code class="hljs c">e) <span class="hljs-type">int</span> * a[<span class="hljs-number">10</span>];f) <span class="hljs-type">int</span> (*a)[<span class="hljs-number">10</span>]g) <span class="hljs-type">int</span> (*a)(<span class="hljs-type">int</span>);h) <span class="hljs-type">int</span> (*a[<span class="hljs-number">10</span>])(<span class="hljs-type">int</span>)</code></pre></li><li><p>设有以下说明和定义：</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> </span><span class="hljs-class">&#123;</span><span class="hljs-type">long</span> i; <span class="hljs-type">int</span> k[<span class="hljs-number">5</span>]; <span class="hljs-type">char</span> c;&#125; DATA;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data</span> </span><span class="hljs-class">&#123;</span> <span class="hljs-type">int</span> cat; DATA cow; <span class="hljs-type">double</span> dog;&#125; too;DATA max;则语句<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-keyword">sizeof</span>(max) + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> data) ); 的执行结果是：</code></pre><p> <strong>32位下：</strong><br>sizeof(DATA) &#x3D; 20<br>sizeof(struct data) &#x3D; 32<br>执行结果：52<br>解析：<br>DATA中最大内存变量为数组k，占用20个字节，超出了32位下操作系统基本字节单位（4），所以4字节对齐，但是对齐后还是20。struct data中int占用4个字节，DATA占用20个字节，double占用8个字节，一共32个字节，刚好也可以4字节对齐，所以最终为32。它们相加为52。<br><strong>64位下：</strong><br>sizeof(DATA) &#x3D; 24<br>sizeof(struct data) &#x3D; 40<br>执行结果：64<br>DATA中最大内存变量为数组k，占用20个字节，超过了64位下操作系统基本字节单位（8），所以8字节对齐，最后为24。truct data中int占用8个字节，DATA占用20个字节，double占用8个字节，一共36个字节，8字节对齐后为40，其中补齐的4个字节在DATA后面。最终它们相加等于64。<br>另外，以上是在ubuntu18.04下使用系统自带GCC编译器实验的。实际我在windows10下使用x86_64-w64-mingw32指定 -m64 编译64位程序仍旧和 -m32 下一样，可能还是和编译器有关。 </p><p><strong>结构体对齐规则：</strong></p><p>1、第一个成员在与结构体变量偏移量为0的地址处；<br>2、其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处（对齐数&#x3D;编译器默认的一个对齐数 与 该成员大小的<strong>较小值</strong>）（ vs中默认的值为8）；<br>3、结构体总大小为<strong>最大对齐数</strong>（每个成员变量都有一个对齐数）的整数倍；</p><p>4、如果嵌套了结构体的情况，嵌套的结构体对齐到该结构体自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构的对齐数）的整数倍。</p></li><li><p>请问以下代码有什么问题：</p><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<span class="hljs-type">char</span> a;<span class="hljs-type">char</span> *str=&amp; a;    <span class="hljs-built_in">strcpy</span>(str,<span class="hljs-string">&quot;hello&quot;</span>);    <span class="hljs-comment">// 越界</span>    <span class="hljs-built_in">printf</span>(str);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li><li><pre><code class="language-c">//请问以下代码有什么问题：char * s =&quot;AAA&quot;;printf(&quot;%s&quot;,s);s[0]=&#39;B&#39;;printf(&quot;%s&quot;,s);//有什么错？/*char* s = &quot;AAA&quot;;：这一行代码将字符串字面量 &quot;AAA&quot; 的地址赋给了指针 s。在 C/C++ 中，字符串字面量通常存储在只读的内存区域（如 .rodata 段）。因此，通过 s 指向的这段内存通常是不可修改的。不要修改字符串字面量：在 C/C++ 中，字符串字面量通常存储在只读内存区域，试图修改它们会导致未定义行为，可能会导致程序崩溃。使用字符数组：如果需要可修改的字符串，应该使用字符数组而不是指向字符串字面量的指针。这不仅安全，而且是正确的做法。*/<pre><code class="hljs plaintext">   7.    ```c   int (*s[10])(int)  //表示的是什么</code></pre> 答案：int (*s[10])(int) 函数指针数组，每个指针指向一个int func ( int param) 的函数。（或一个有10个指针的数组，每个指针指向一个函数，该函数有一个整型参数并返回一个整型数） </code></pre></li><li><p>c和c++ 中的struct有什么不同？</p><p> c和c++ 中struct的主要区别是c中的struct不可以含有成员函数，而c++ 中的struct可以。c++ 中struct和class的主要区别在于默认的存取权限不同，struct默认为public ，而class默认为private </p></li><li><pre><code class="language-c">void getmemory(char *p)&#123;    p=(char *) malloc(100);    // strcpy默认给p后面补一个\0    strcpy(p,“hello world”);&#125;int main( )&#123;    char *str=NULL;    getmemory(str);    printf(“%s\n”,str);    free(str);    return 0;&#125; //会出现什么问题？    //<pre><code class="hljs plaintext">**分析：**这段代码中存在一个问题：在 `getmemory` 函数中，`p` 是一个局部变量，它指向动态分配的内存。当你调用 `free(str)` 时，`str` 已经不再是有效的指针，因为它没有保存动态分配的内存的地址。下面是改进后的代码：```c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void getmemory(char **p)&#123;    *p = (char *)malloc(11);  // 注意：需要分配足够的空间容纳字符串和结束符&#x27;\0&#x27;    if (*p != NULL)        strcpy(*p, &quot;hello world&quot;);&#125;int main(void)&#123;    char *str = NULL;    getmemory(&amp;str);    if (str != NULL)    &#123;        printf(&quot;%s\n&quot;, str);        free(str);    &#125;    return 0;&#125;</code></pre>在这段改进后的代码中，`getmemory` 函数接受一个指向指针的指针 `char **p`，这样就可以更新外部的 `str` 指针。此外，确保分配足够的空间来存放字符串和结束符 `\0`。最后，在 `main` 函数中检查 `str` 是否为 `NULL`，防止在释放之前打印无效的字符串。现在，这段代码应该能够正确地分配内存、打印字符串，并释放内存。</code></pre></li><li><pre><code class="language-c">char szstr[10];strcpy(szstr,&quot;0123456789&quot;);// 产生什么结果？为什么？// 越界。 字符串多一个’\0’结束符<pre><code class="hljs plaintext">11.     ```c    void main()    &#123;    char aa[10];    printf(“%d”,strlen(aa));    &#125;                                              // 会出现什么问题？打印结果是是多少？    // 打印结果未知</code></pre></code></pre></li><li><pre><code class="language-c">struct A&#123;    char t:4;    char k:4;    unsigned short i:8;    unsigned long m;&#125;; 问sizeof(A) = ?8<pre><code class="hljs plaintext">13. ```c    struct name1    &#123;    char str;    short x;    int num;    &#125; ;求sizeof(name1)?    8</code></pre></code></pre></li><li><pre><code class="language-c">struct name2&#123;    char str;    int num;    short x;&#125;; 求sizeof(name2)？32:1264:12<pre><code class="hljs plaintext">15. ```c    // 程序哪里有错误    wap( int *p1,int *p2 )    &#123;    int  *p;    *p = *p1;    *p1 = *p2;    *p2 = *p;    &#125;    // 答案：申请p的时候没有初始化，所以p为野指针。</code></pre></code></pre></li><li><pre><code class="language-c">(void *)ptr 和(*(void**))ptr 的结果是否相同？其中ptr为同一个指针。答案：(void )ptr 和((void**))ptr 值是相同的详解：个人理解，void前面的*是取该地址内容的，所以本质一样<pre><code class="hljs plaintext">17. ```c    要对绝对地址0x100000赋值，我们可以用    (unsigned int*)0x100000 = 1234;    那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？    答案：((void ()( ))0x100000 ) ( );    首先要将0x100000强制转换成函数指针,即:    (void (*)(void))0x100000    然后再调用它:    ((void (*)(void))0x100000)();</code></pre></code></pre></li><li><pre><code class="language-c">关键字volatile有什么含意? 并给出三个不同的例子。解释：当我们说某个变量是 `volatile` 类型时，意味着这个变量的值可能会在编译器不知道的情况下发生变化。这意味着编译器不能对这个变量进行优化，每次访问它时都要从内存中读取或写入最新值。举个例子，想象一下有一个灯泡开关，你正在编写一个程序来控制它。当你按下开关时，灯泡就会亮起或熄灭。但是，你不能预测别人是否会同时按下开关。在这种情况下，你需要确保每次检查开关状态时，都能得到最新的信息，而不是基于之前的假设。这就是 `volatile` 关键字的作用。它告诉编译器：“嘿！这个变量的值可能会随时改变，所以我需要每次访问它时都从内存中读取。” 这样，即使其他人（或者其他程序、设备）改变了变量的值，你的程序也能及时发现并作出反应。简单地说，`volatile` 关键字就是告诉编译器：“别管我，让我自己来处理这个变量！”    总结来说，volatile 关键字告诉编译器不要对变量进行优化，而是每次都从内存中读取或写入。这对于多线程编程、中断服务例程以及与 I/O 设备交互的情况特别有用。<pre><code class="hljs plaintext">19. ```c    头文件中的ifndef/define/endif 干什么用？    防止头文件被重复引用</code></pre></code></pre></li><li><pre><code class="language-c">#include  &lt;filename.h&gt;    和    #include  “filename.h” 有什么区别？//引用系统文件  自定义文件 答案：对于#include &lt;filename.h&gt; ，编译器从标准库路径开始搜索filename.h ; 对于#include “filename.h” ，编译器从用户的工作路径开始搜索filename.h 。<pre><code class="hljs plaintext">21. ```c    const   有什么用途？（请至少说明两种）    (1)可以定义const 常量（2）const 可以修饰函数的参数、返回值，甚至函数的定义体。被const 修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。</code></pre></code></pre></li><li><pre><code class="language-c">32.static有什么用途？（请至少说明两种）<pre><code class="hljs plaintext">    在 C/C++ 中，`static` 关键字有多种用途，取决于它的上下文。以下是 `static` 在不同上下文中的一些主要作用：    1. **全局变量和局部变量**：`static` 可以用来修饰全局变量和局部变量。       - 当 `static` 修饰全局变量时，它限制了变量的作用域，使其只能在当前源文件中可见。这有助于避免命名冲突和其他潜在的问题。              - 当 `static` 修饰局部变量时，它改变了变量的生命周期。静态局部变量会在程序运行期间一直存在，而不是在离开作用域后被销毁。每次进入函数时，静态局部变量都会保留之前的状态。    2. **函数参数**：`static` 不适用于函数参数，因为参数总是具有自动存储类别。    3. **类成员变量**：在 C++ 中，`static` 可以修饰类成员变量。静态成员变量属于整个类，而非单个对象。这意味着所有对象共享同一份静态成员变量的副本。    4. **类成员函数**：在 C++ 中，`static` 可以修饰类成员函数。静态成员函数不依赖于特定的对象实例，可以直接通过类名调用。它们不能访问非静态成员变量或调用非静态成员函数。    5. **模块内部链接性**：在 C/C++ 中，`extern static` 可以用来声明一个具有内部链接性的变量或函数。这意味着该实体只能在当前编译单元中访问，而不能从其他编译单元访问。    6. **C++ 中的名称空间范围**：在 C++ 中，`static` 可以用来限制名称空间中的名字的作用域，使其只在当前名称空间中有效。    7. **C++ 中的多态性**：在 C++ 中，`virtual` 和 `static` 成员函数都可以实现多态性。`virtual` 成员函数基于对象的实际类型动态绑定，而 `static` 成员函数则始终基于函数调用的方式（即类名或对象引用）绑定。    总之，`static` 关键字在 C/C++ 中扮演着重要的角色，用于控制变量的作用域、生命周期和链接性，以及类成员的行为。在编程时，理解 `static` 的含义和用法非常重要，因为它会影响程序的行为和性能。23. 堆栈溢出一般是由什么原因导致的？    没有及时回收垃圾资源24. 如何引用一个已经定义过的全局变量？     答案：可以用引用头文件的方式，也可以用extern 关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变量写错了，那么在编译期间会报错，如果你用extern 方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。     ‌**在‌[C语言](https://www.baidu.com/s?word=C语言&amp;sa=re_dqa_zy)中，引用已经定义过的全局变量可以通过两种主要方式实现：使用`extern`关键字或通过包含定义该变量的头文件。**‌    -        ‌**使用`extern`关键字**‌：当全局变量定义在另一个文件中时，可以在当前文件中使用`extern`关键字来声明该变量，表明该变量已经在其他地方定义过了。例如，如果全局变量在`global_vars.c`中定义，那么在`main.c`中可以通过以下方式引用该变量：      ```c      extern int globalVariable;</code></pre>  这样声明后，就可以在当前文件中使用`globalVariable`变量了。-    ‌**通过包含定义变量的头文件**‌：如果全局变量定义在一个头文件中，那么只需要在需要使用该变量的文件中包含这个头文件即可。例如，如果全局变量在`global_vars.h`中定义，那么在`main.c`中可以通过以下方式引用该变量：  <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;global_vars.h&quot;</span> <span class="hljs-comment">// 假设全局变量在这个头文件中定义</span></span></code></pre>  包含头文件后，编译器会处理头文件中的全局变量声明，从而允许在当前文件中直接使用这些全局变量。这两种方法都可以有效地引用已经定义过的全局变量，选择哪种方法取决于变量的具体定义方式和项目结构</code></pre></li></ol><p>在 C&#x2F;C++ 中，<code>extern</code> 关键字用于声明一个变量或函数已经在其他地方定义过了。它告诉编译器变量或函数存在于外部，但不在当前文件中定义。<code>extern</code> 关键字主要用于解决以下两种情况：</p><ol><li><p><strong>跨文件引用全局变量</strong>：当你有一个全局变量在某个文件中定义，而在其他文件中想要使用它时，你需要在其他文件中使用 <code>extern</code> 关键字声明这个变量。这样，编译器就会知道变量在其他地方定义，而不是在这个文件中定义。</p></li><li><p><strong>声明外部函数</strong>：当你在一个文件中定义了一个函数，但在其他文件中使用它时，你需要在其他文件中使用 <code>extern</code> 关键字声明这个函数。这样，编译器就会知道函数在其他地方定义，而不是在这个文件中定义。</p></li></ol><p>下面是一些使用 <code>extern</code> 关键字的例子：</p><p><strong>全局变量</strong></p><p>首先，在一个文件中定义全局变量：</p><pre><code class="hljs c"><span class="hljs-comment">// global_variable.cpp</span><span class="hljs-type">int</span> g_global_var = <span class="hljs-number">42</span>;</code></pre><p>然后，在另一个文件中使用 <code>extern</code> 关键字声明全局变量：</p><pre><code class="hljs c"><span class="hljs-comment">// main.cpp</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> g_global_var; <span class="hljs-comment">// 声明全局变量</span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Global variable value: &quot;</span> &lt;&lt; g_global_var &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>函数</strong></p><p>首先，在一个文件中定义函数：</p><pre><code class="hljs c"><span class="hljs-comment">// function.cpp</span><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;    <span class="hljs-keyword">return</span> a + b;&#125;</code></pre><p>然后，在另一个文件中使用 <code>extern</code> 关键字声明函数：</p><pre><code class="hljs c"><span class="hljs-comment">// main.cpp</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>; <span class="hljs-comment">// 声明函数</span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">int</span> result = add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Result of addition: &quot;</span> &lt;&lt; result &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><code>extern</code> 关键字还可以用于延迟变量的初始化。例如，你可以在头文件中声明一个全局变量，然后在某个源文件中初始化它：</p><pre><code class="hljs c"><span class="hljs-comment">// global_variable.h</span><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> GLOBAL_VARIABLE_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> GLOBAL_VARIABLE_H</span><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> g_global_var;<span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// GLOBAL_VARIABLE_H</span></span></code></pre><pre><code class="hljs c"><span class="hljs-comment">// global_variable.cpp</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;global_variable.h&quot;</span></span><span class="hljs-type">int</span> g_global_var = <span class="hljs-number">42</span>;</code></pre><pre><code class="hljs c"><span class="hljs-comment">// main.cpp</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;global_variable.h&quot;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Global variable value: &quot;</span> &lt;&lt; g_global_var &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>在这个例子中，<code>main.cpp</code> 引用了 <code>g_global_var</code>，但并没有定义它。<code>global_variable.cpp</code> 提供了实际的定义。<code>extern</code> 关键字告诉编译器 <code>g_global_var</code> 已经在其他地方定义了，这样就不会产生多个定义的错误。</p><ol start="25"><li><p>全局变量可不可以定义在可被多个.C 文件包含的头文件中？为什么？</p><p> 答案：可以，在不同的C 文件中以static形式来声明同名全局变量。可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错 </p></li><li><p>Heap与stack的差别。</p><p> 答案：Heap是堆，stack是栈。Stack的空间由操作系统自动分配&#x2F;释放，Heap上的空间手动分配&#x2F;释放。Stack空间有限，Heap是很大的自由存储区C 中的malloc 函数分配的内存空间即在堆上,C++中对应的是new 操作符。程序在编译期对变量和函数分配内存都在栈上进行,且程序运行过程中函数调用时参数的传递也在栈上进行。 </p></li><li><p>用宏定义写出swap（x，y），即交换两数。</p></li></ol><pre><code><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> swap(x, y) (x)=(x)+(y);(y)=(x)–(y);(x)=(x)–(y);</span></code></pre></code></pre><ol start="28"><li><p>39.写一个“标准”宏，这个宏输入两个参数并返回较小的一个。</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> min(x, y) ((x)&lt;(y)?(x):(y))</span><span class="hljs-comment">// 结尾没有 ;</span><span class="hljs-comment">/*</span><span class="hljs-comment">在 C/C++ 宏定义中，末尾不需要加分号（;）。宏定义是一种文本替换机制，当预处理器遇到宏定义时，它会将宏名及其参数替换为宏体内的文本。因此，分号不是必需的，除非宏体本身需要分号作为语句的一部分。</span><span class="hljs-comment"></span><span class="hljs-comment">例如，min(x, y) 这个宏定义会在调用时展开成 (x) &lt; (y) ? (x) : (y)，这是一个表达式，不需要分号结束。当你在代码中使用这个宏时，它会被插入到现有代码中，成为更大的表达式的一部分，或者作为一个独立的语句。在这种情况下，分号由调用方添加，而不是宏定义本身。</span><span class="hljs-comment">*/</span></code></pre></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>gdb调试</title>
      <link href="/2024/08/14/linux-gdb/"/>
      <url>/2024/08/14/linux-gdb/</url>
      
        <content type="html"><![CDATA[<h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. <strong>基本使用</strong></h3><h4 id="1-1-编译程序"><a href="#1-1-编译程序" class="headerlink" title="1.1 编译程序"></a>1.1 <strong>编译程序</strong></h4><p>确保编译时包含调试信息：</p><pre><code class="hljs bash">gcc -g -o myprogram myprogram.c</code></pre><h4 id="1-2-启动-GDB"><a href="#1-2-启动-GDB" class="headerlink" title="1.2 启动 GDB"></a>1.2 <strong>启动 GDB</strong></h4><pre><code class="hljs bash">gdb myprogram</code></pre><p>可以附带参数来启动程序：</p><pre><code class="hljs bash">gdb --args myprogram arg1 arg2</code></pre><h3 id="2-调试会话"><a href="#2-调试会话" class="headerlink" title="2. 调试会话"></a>2. <strong>调试会话</strong></h3><h4 id="2-1-设置断点"><a href="#2-1-设置断点" class="headerlink" title="2.1 设置断点"></a>2.1 <strong>设置断点</strong></h4><ul><li><p><strong>在函数入口设置断点</strong>：</p><pre><code class="hljs gdb">(gdb) break main</code></pre></li><li><p><strong>在特定行设置断点</strong>：</p><pre><code class="hljs gdb">(gdb) break myfile.c:42</code></pre></li><li><p><strong>设置条件断点</strong>（只有在条件满足时断点才会触发）：</p><pre><code class="hljs gdb">(gdb) break 42 if x &gt; 10</code></pre></li></ul><h4 id="2-2-删除和查看断点"><a href="#2-2-删除和查看断点" class="headerlink" title="2.2 删除和查看断点"></a>2.2 <strong>删除和查看断点</strong></h4><ul><li><p><strong>删除所有断点</strong>：</p><pre><code class="hljs gdb">(gdb) delete</code></pre></li><li><p><strong>删除指定断点</strong>：</p><pre><code class="hljs gdb">(gdb) delete 1</code></pre></li><li><p><strong>查看所有断点</strong>：</p><pre><code class="hljs gdb">(gdb) info breakpoints</code></pre></li></ul><h4 id="2-3-运行和停止"><a href="#2-3-运行和停止" class="headerlink" title="2.3 运行和停止"></a>2.3 <strong>运行和停止</strong></h4><ul><li><p><strong>运行程序</strong>：</p><pre><code class="hljs gdb">(gdb) run</code></pre></li><li><p><strong>停止程序</strong>（如果已经在运行）：</p><pre><code class="hljs gdb">(gdb) kill</code></pre></li><li><p><strong>继续执行程序</strong>（直到下一个断点）：</p><pre><code class="hljs gdb">(gdb) continue</code></pre></li><li><p><strong>单步执行代码</strong>（进入函数内部）：</p><pre><code class="hljs gdb">(gdb) step</code></pre></li><li><p><strong>单步执行代码</strong>（不进入函数内部）：</p><pre><code class="hljs gdb">(gdb) next</code></pre></li><li><p><strong>完成当前函数的执行</strong>（并返回到调用者）：</p><pre><code class="hljs gdb">(gdb) finish</code></pre></li></ul><h3 id="3-变量和内存检查"><a href="#3-变量和内存检查" class="headerlink" title="3. 变量和内存检查"></a>3. <strong>变量和内存检查</strong></h3><h4 id="3-1-查看变量值"><a href="#3-1-查看变量值" class="headerlink" title="3.1 查看变量值"></a>3.1 <strong>查看变量值</strong></h4><ul><li><p><strong>查看变量的值</strong>：</p><pre><code class="hljs gdb">(gdb) print x</code></pre></li><li><p><strong>查看结构体成员</strong>：</p><pre><code class="hljs gdb">(gdb) print myStruct.member</code></pre></li><li><p><strong>监视变量的变化</strong>（每次程序停止时自动显示变量值）：</p><pre><code class="hljs gdb">(gdb) display x</code></pre></li><li><p><strong>取消监视变量</strong>：</p><pre><code class="hljs gdb">(gdb) undisplay 1</code></pre></li></ul><h4 id="3-2-查看内存内容"><a href="#3-2-查看内存内容" class="headerlink" title="3.2 查看内存内容"></a>3.2 <strong>查看内存内容</strong></h4><ul><li><p><strong>查看内存中的内容</strong>（以十六进制格式显示）：</p><pre><code class="hljs gdb">(gdb) x/10x &amp;x</code></pre></li><li><p><strong>查看内存中的内容</strong>（以字符格式显示）：</p><pre><code class="hljs gdb">(gdb) x/10c &amp;x</code></pre></li></ul><h3 id="4-调用栈和函数"><a href="#4-调用栈和函数" class="headerlink" title="4. 调用栈和函数"></a>4. <strong>调用栈和函数</strong></h3><h4 id="4-1-查看调用栈"><a href="#4-1-查看调用栈" class="headerlink" title="4.1 查看调用栈"></a>4.1 <strong>查看调用栈</strong></h4><ul><li><p><strong>显示调用栈</strong>：</p><pre><code class="hljs gdb">(gdb) backtrace</code></pre></li><li><p><strong>显示特定帧的调用栈信息</strong>：</p><pre><code class="hljs gdb">(gdb) frame 2</code></pre></li></ul><h4 id="4-2-查看函数信息"><a href="#4-2-查看函数信息" class="headerlink" title="4.2 查看函数信息"></a>4.2 <strong>查看函数信息</strong></h4><ul><li><p><strong>列出当前函数中的所有局部变量</strong>：</p><pre><code class="hljs gdb">(gdb) info locals</code></pre></li><li><p><strong>列出当前函数中的所有参数</strong>：</p><pre><code class="hljs gdb">(gdb) info args</code></pre></li></ul><h3 id="5-多线程调试"><a href="#5-多线程调试" class="headerlink" title="5. 多线程调试"></a>5. <strong>多线程调试</strong></h3><h4 id="5-1-查看线程信息"><a href="#5-1-查看线程信息" class="headerlink" title="5.1 查看线程信息"></a>5.1 <strong>查看线程信息</strong></h4><ul><li><p><strong>列出所有线程</strong>：</p><pre><code class="hljs gdb">(gdb) info threads</code></pre></li><li><p><strong>切换到特定线程</strong>：</p><pre><code class="hljs gdb">(gdb) thread 2</code></pre></li><li><p><strong>查看当前线程的信息</strong>：</p><pre><code class="hljs gdb">(gdb) info thread</code></pre></li></ul><h4 id="5-2-在多线程中设置断点"><a href="#5-2-在多线程中设置断点" class="headerlink" title="5.2 在多线程中设置断点"></a>5.2 <strong>在多线程中设置断点</strong></h4><ul><li><strong>在特定线程中设置断点</strong>（断点只在该线程触发）：<pre><code class="hljs gdb">(gdb) break myfile.c:42 if (thread_id == 2)</code></pre></li></ul><h3 id="6-高级调试技术"><a href="#6-高级调试技术" class="headerlink" title="6. 高级调试技术"></a>6. <strong>高级调试技术</strong></h3><h4 id="6-1-条件断点"><a href="#6-1-条件断点" class="headerlink" title="6.1 条件断点"></a>6.1 <strong>条件断点</strong></h4><ul><li><strong>设置断点，只有在条件满足时才会触发</strong>：<pre><code class="hljs gdb">(gdb) break myfile.c:42 if x &gt; 10</code></pre></li></ul><h4 id="6-2-监视点"><a href="#6-2-监视点" class="headerlink" title="6.2 监视点"></a>6.2 <strong>监视点</strong></h4><ul><li><p><strong>设置监视点（在变量的值发生变化时停下）</strong>：</p><pre><code class="hljs gdb">(gdb) watch x</code></pre></li><li><p><strong>设置读写监视点（在变量的值被读写时停下）</strong>：</p><pre><code class="hljs gdb">(gdb) awatch x</code></pre></li><li><p><strong>设置只读监视点（在变量的值被读取时停下）</strong>：</p><pre><code class="hljs gdb">(gdb) rwatch x</code></pre></li></ul><h4 id="6-3-动态调试"><a href="#6-3-动态调试" class="headerlink" title="6.3 动态调试"></a>6.3 <strong>动态调试</strong></h4><ul><li><p><strong>使用 <code>call</code> 执行 C 语言表达式</strong>：</p><pre><code class="hljs gdb">(gdb) call myFunction(1, 2)</code></pre></li><li><p><strong>改变变量的值</strong>：</p><pre><code class="hljs gdb">(gdb) set var x = 5</code></pre></li></ul><h3 id="7-调试符号和文件"><a href="#7-调试符号和文件" class="headerlink" title="7. 调试符号和文件"></a>7. <strong>调试符号和文件</strong></h3><h4 id="7-1-加载符号文件"><a href="#7-1-加载符号文件" class="headerlink" title="7.1 加载符号文件"></a>7.1 <strong>加载符号文件</strong></h4><ul><li><strong>加载调试符号文件</strong>：<pre><code class="hljs gdb">(gdb) symbol-file myprogram</code></pre></li></ul><h4 id="7-2-加载程序"><a href="#7-2-加载程序" class="headerlink" title="7.2 加载程序"></a>7.2 <strong>加载程序</strong></h4><ul><li><strong>重新加载程序和符号信息</strong>：<pre><code class="hljs gdb">(gdb) file myprogram</code></pre></li></ul><h3 id="8-使用-GDB-脚本"><a href="#8-使用-GDB-脚本" class="headerlink" title="8. 使用 GDB 脚本"></a>8. <strong>使用 GDB 脚本</strong></h3><h4 id="8-1-编写-GDB-脚本"><a href="#8-1-编写-GDB-脚本" class="headerlink" title="8.1 编写 GDB 脚本"></a>8.1 <strong>编写 GDB 脚本</strong></h4><ul><li><strong>GDB 脚本文件</strong>（如 <code>myscript.gdb</code>）：<pre><code class="hljs gdb">break mainruninfo locals</code></pre></li></ul><h4 id="8-2-执行-GDB-脚本"><a href="#8-2-执行-GDB-脚本" class="headerlink" title="8.2 执行 GDB 脚本"></a>8.2 <strong>执行 GDB 脚本</strong></h4><ul><li><strong>在 GDB 会话中执行脚本</strong>：<pre><code class="hljs gdb">(gdb) source myscript.gdb</code></pre></li></ul><h3 id="9-调试优化代码"><a href="#9-调试优化代码" class="headerlink" title="9. 调试优化代码"></a>9. <strong>调试优化代码</strong></h3><ul><li><strong>禁用优化以进行调试</strong>（编译时使用 <code>-O0</code>）：<pre><code class="hljs bash">gcc -g -O0 -o myprogram myprogram.c</code></pre></li></ul><h3 id="10-调试动态库"><a href="#10-调试动态库" class="headerlink" title="10. 调试动态库"></a>10. <strong>调试动态库</strong></h3><ul><li><strong>加载动态库中的调试信息</strong>：<pre><code class="hljs gdb">(gdb) set solib-search-path /path/to/libs</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux-select和epoll</title>
      <link href="/2024/08/14/linux-select%E5%92%8Cepoll/"/>
      <url>/2024/08/14/linux-select%E5%92%8Cepoll/</url>
      
        <content type="html"><![CDATA[<p>IO多路复用技术主要为了解决在网络编程中处理大量并发连接时遇到的问题。下面是IO多路复用技术所解决的关键问题：</p><ol><li><p><strong>性能瓶颈</strong>：</p><ul><li>在传统的网络编程模型中，每个客户端连接都需要一个单独的线程或进程来处理。</li><li>当客户端连接数量非常大时，这种模型会导致大量的线程或进程开销，包括上下文切换和内存管理等。</li></ul></li><li><p><strong>资源管理</strong>：</p><ul><li>传统模型中的每个连接都需要一个线程或进程，这会导致较高的内存和CPU使用率。</li><li>在多路复用模型中，可以使用较少的线程或进程来处理大量的连接，从而更有效地利用资源。</li></ul></li><li><p><strong>并发连接的处理</strong>：</p><ul><li>传统模型难以有效处理大量并发连接，因为每个连接都需要独立的线程或进程。</li><li>多路复用技术允许一个线程或进程同时监听多个文件描述符（通常是网络套接字），从而可以同时处理多个连接。</li></ul></li><li><p><strong>避免轮询</strong>：</p><ul><li>在没有多路复用的情况下，服务器可能需要不断轮询每个连接的状态，以检查是否有数据可以读取或写入。</li><li>多路复用技术允许服务器等待一组文件描述符中的任意一个或多个变为就绪状态，而不是不断轮询。</li></ul></li><li><p><strong>提高性能</strong>：</p><ul><li>通过减少上下文切换和轮询，多路复用技术可以显著提高服务器处理大量并发连接的能力。</li><li>这种方法可以降低CPU和内存的使用率，提高系统的响应时间和吞吐量。</li></ul></li></ol><h3 id="具体技术"><a href="#具体技术" class="headerlink" title="具体技术"></a>具体技术</h3><p>一些常用的IO多路复用技术包括：</p><ul><li><p><strong><code>select</code></strong>：</p><ul><li><code>select</code> 是最早的多路复用技术之一，它允许同时监听多个文件描述符。</li><li>它有一个限制，即最多只能监听 FD_SETSIZE 个文件描述符（通常是 1024）。</li></ul></li><li><p><strong><code>poll</code></strong>：</p><ul><li><code>poll</code> 类似于 <code>select</code>，但是没有文件描述符数量的限制。</li><li><code>poll</code> 仍然使用轮询的方式检查文件描述符的状态，但它的效率通常高于 <code>select</code>。</li></ul></li><li><p><strong><code>epoll</code></strong>：</p><ul><li><code>epoll</code> 是 Linux 内核中的一种高效的多路复用技术。</li><li>它使用边缘触发（edge-triggered）和水平触发（level-triggered）模式来提高性能。</li><li><code>epoll</code> 使用红黑树等数据结构来高效地管理文件描述符。</li></ul></li><li><p><strong><code>kqueue</code></strong>：</p><ul><li><code>kqueue</code> 是 BSD 系统中的多路复用技术。</li><li>它提供了类似于 <code>epoll</code> 的功能，但在 BSD 系统中更为常见。</li></ul></li></ul><p><code>select</code> 是一种用于多路复用 I&#x2F;O 操作的系统调用，在处理多个文件描述符时非常有用。它允许程序在等待多个文件描述符的状态变化时阻塞，从而在网络编程和并发 I&#x2F;O 操作中广泛应用。</p><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. <strong>基本概念</strong></h3><ul><li><strong>多路复用 I&#x2F;O</strong>: 在网络编程中，通常需要同时处理多个 I&#x2F;O 操作，如监视多个套接字的状态。<code>select</code> 允许程序同时等待多个文件描述符的状态变化，如读、写或异常情况，而不必为每个文件描述符创建一个线程。</li><li><strong>文件描述符（File Descriptor）</strong>: 在UNIX&#x2F;Linux系统中，文件描述符是一个整数，表示打开的文件、套接字或其他I&#x2F;O资源。</li></ul><h3 id="2-函数原型"><a href="#2-函数原型" class="headerlink" title="2. 函数原型"></a>2. <strong>函数原型</strong></h3>   <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="hljs-keyword">struct</span> timeval *timeout)</span>;</code></pre><ul><li><p><code>nfds</code>: 需要监视的文件描述符的数量。通常设置为所有文件描述符中最大值加1。</p></li><li><p><code>readfds</code>: 指向 <code>fd_set</code> 结构体的指针，用于监视可读的文件描述符集合。</p></li><li><p><code>writefds</code>: 指向 <code>fd_set</code> 结构体的指针，用于监视可写的文件描述符集合。</p></li><li><p><code>exceptfds</code>: 指向 <code>fd_set</code> 结构体的指针，用于监视异常状态的文件描述符集合。</p></li><li><p><code>timeout</code>: 指向 <code>timeval</code> 结构体的指针，表示等待的超时时间。如果 <code>timeout</code> 为 <code>NULL</code>，则 <code>select</code> 会无限期地阻塞直到有文件描述符发生变化。</p></li><li><p><strong>返回值</strong>:</p><ul><li>成功时，返回值为文件描述符集合中发生变化的文件描述符数量。</li><li>如果超时返回，返回值为 0。</li><li>如果出错，返回值为 -1，且 <code>errno</code> 被设置为适当的错误代码。</li></ul></li></ul><h3 id="3-使用步骤"><a href="#3-使用步骤" class="headerlink" title="3. 使用步骤"></a>3. <strong>使用步骤</strong></h3><ol><li><strong>设置文件描述符集</strong>: 使用 <code>FD_ZERO</code> 清空文件描述符集，然后使用 <code>FD_SET</code> 将需要监视的文件描述符加入集合中。</li><li><strong>调用 <code>select</code></strong>: 传递文件描述符集合，<code>select</code> 将阻塞直到至少一个文件描述符的状态发生变化，或超时时间到。</li><li><strong>检查结果</strong>: 使用 <code>FD_ISSET</code> 检查哪些文件描述符发生了状态变化，然后处理相应的 I&#x2F;O 操作。</li><li><strong>处理超时</strong>: 如果 <code>select</code> 返回 0，表示已超时，可以根据应用需要处理这个情况。</li></ol><h3 id="4-简单示例"><a href="#4-简单示例" class="headerlink" title="4. 简单示例"></a>4. <strong>简单示例</strong></h3><p>   下面是一个简单的例子，演示如何使用 <code>select</code> 监视标准输入和一个套接字的可读性：<br>   <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;    fd_set readfds;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">timeout</span>;</span>    <span class="hljs-type">int</span> retval;    FD_ZERO(&amp;readfds);  <span class="hljs-comment">// 清空文件描述符集</span>    FD_SET(STDIN_FILENO, &amp;readfds);  <span class="hljs-comment">// 监视标准输入</span>    timeout.tv_sec = <span class="hljs-number">5</span>;  <span class="hljs-comment">// 超时等待5秒</span>    timeout.tv_usec = <span class="hljs-number">0</span>;    retval = select(STDIN_FILENO + <span class="hljs-number">1</span>, &amp;readfds, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;timeout);    <span class="hljs-keyword">if</span> (retval == <span class="hljs-number">-1</span>) &#123;        perror(<span class="hljs-string">&quot;select()&quot;</span>);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (retval) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Data is available now.\n&quot;</span>);        <span class="hljs-keyword">if</span> (FD_ISSET(STDIN_FILENO, &amp;readfds)) &#123;            <span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];            read(STDIN_FILENO, buffer, <span class="hljs-keyword">sizeof</span>(buffer));            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input: %s\n&quot;</span>, buffer);        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No data within five seconds.\n&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></p><h3 id="5-常见应用场景"><a href="#5-常见应用场景" class="headerlink" title="5. 常见应用场景"></a>5. <strong>常见应用场景</strong></h3><ul><li><strong>网络服务器</strong>: 在服务器端同时处理多个客户端连接时，<code>select</code> 可以用于监视多个客户端套接字的读写状态。</li><li><strong>并发 I&#x2F;O</strong>: 在不使用多线程或多进程的情况下，<code>select</code> 可以帮助处理多个 I&#x2F;O 设备，如文件、套接字或管道。</li><li><strong>超时控制</strong>: <code>select</code> 允许程序在等待 I&#x2F;O 操作时设置超时，以避免长时间阻塞。</li></ul><h3 id="6-优缺点"><a href="#6-优缺点" class="headerlink" title="6. 优缺点"></a>6. <strong>优缺点</strong></h3><ul><li><strong>优点</strong>:<ul><li>简单易用，跨平台支持良好。</li><li>无需创建大量线程或进程，节省资源。</li></ul></li><li><strong>缺点</strong>:<ul><li><code>select</code> 的性能在大量文件描述符（通常超过1024个）时会显著下降。</li><li>每次调用 <code>select</code> 都需要重新设置文件描述符集合，效率较低。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p><code>select</code> 是一个在网络编程和并发 I&#x2F;O 中广泛使用的系统调用，通过监视多个文件描述符的状态变化来实现 I&#x2F;O 多路复用。虽然 <code>select</code> 在处理少量文件描述符时表现良好，但在处理大量文件描述符时性能较差，因此在现代应用中，<code>poll</code> 和 <code>epoll</code> 等替代方案可能更合适。</p><p><code>epoll</code> 是 Linux 内核提供的一种高效的 I&#x2F;O 多路复用机制，相比于传统的 <code>select</code> 和 <code>poll</code>，<code>epoll</code> 能够更高效地处理大量并发连接，尤其是在处理大规模网络服务时表现出色。</p><h3 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1. 基本概念"></a>1. <strong>基本概念</strong></h3><ul><li><strong>I&#x2F;O 多路复用</strong>: 允许程序同时监视多个文件描述符的 I&#x2F;O 事件，并在任一文件描述符就绪时进行相应的处理。这种机制在网络服务器、事件驱动的应用程序中广泛使用。</li><li><strong>epoll</strong>: <code>epoll</code> 是 Linux 提供的 I&#x2F;O 多路复用接口，具有高效的事件通知机制，通过减少内核与用户空间的切换次数以及优化数据结构来提升性能。</li></ul><h3 id="2-函数原型与使用步骤"><a href="#2-函数原型与使用步骤" class="headerlink" title="2. 函数原型与使用步骤"></a>2. <strong>函数原型与使用步骤</strong></h3><p>   <code>epoll</code> 主要包括三个系统调用：<code>epoll_create</code>、<code>epoll_ctl</code> 和 <code>epoll_wait</code>。</p><h4 id="2-1-epoll-create"><a href="#2-1-epoll-create" class="headerlink" title="2.1 epoll_create"></a>2.1 <strong>epoll_create</strong></h4>   <pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span>;</code></pre><ul><li><strong>参数</strong>:<ul><li><code>size</code>: 在 Linux 2.6.8 之前，此参数用于建议内核初始分配的空间大小。现在已被忽略，但必须大于零。</li></ul></li><li><strong>返回值</strong>:<ul><li>成功时返回 <code>epoll</code> 实例的文件描述符。</li><li>失败时返回 -1，并设置 <code>errno</code>。</li></ul></li><li><strong>说明</strong>: <code>epoll_create</code> 用于创建一个 <code>epoll</code> 实例，该实例用于管理将要监视的文件描述符集合。</li></ul><p>   <strong>示例</strong>:<br>   <pre><code class="hljs c"><span class="hljs-type">int</span> epfd = epoll_create(<span class="hljs-number">1</span>);<span class="hljs-keyword">if</span> (epfd == <span class="hljs-number">-1</span>) &#123;    perror(<span class="hljs-string">&quot;epoll_create&quot;</span>);    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);&#125;</code></pre></p><h4 id="2-2-epoll-ctl"><a href="#2-2-epoll-ctl" class="headerlink" title="2.2 epoll_ctl"></a>2.2 <strong>epoll_ctl</strong></h4>   <pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *event)</span>;</code></pre><ul><li><strong>参数</strong>:<ul><li><code>epfd</code>: <code>epoll</code> 实例的文件描述符，由 <code>epoll_create</code> 返回。</li><li><code>op</code>: 表示操作类型，包括 <code>EPOLL_CTL_ADD</code>（注册新的 fd 到 epoll）、<code>EPOLL_CTL_MOD</code>（修改已注册 fd 的监听事件）、<code>EPOLL_CTL_DEL</code>（从 epoll 中删除一个 fd）。</li><li><code>fd</code>: 需要操作的文件描述符。</li><li><code>event</code>: 指向 <code>epoll_event</code> 结构体的指针，描述监听的事件类型和关联的数据。</li></ul></li><li><strong>返回值</strong>:<ul><li>成功时返回 0。</li><li>失败时返回 -1，并设置 <code>errno</code>。</li></ul></li></ul><p>   <strong>示例</strong>:<br>   <pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">event</span>;</span>event.events = EPOLLIN;  <span class="hljs-comment">// 监听可读事件</span>event.data.fd = sockfd;  <span class="hljs-comment">// 设置事件关联的文件描述符</span><span class="hljs-keyword">if</span> (epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, &amp;event) == <span class="hljs-number">-1</span>) &#123;    perror(<span class="hljs-string">&quot;epoll_ctl: sockfd&quot;</span>);    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);&#125;</code></pre></p><h4 id="2-3-epoll-wait"><a href="#2-3-epoll-wait" class="headerlink" title="2.3 epoll_wait"></a>2.3 <strong>epoll_wait</strong></h4>   <pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event *events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span>;</code></pre><ul><li><strong>参数</strong>:<ul><li><code>epfd</code>: <code>epoll</code> 实例的文件描述符。</li><li><code>events</code>: 用于存储从内核得到的事件的数组。</li><li><code>maxevents</code>: 每次调用最多返回的事件数。这个值必须大于 0。</li><li><code>timeout</code>: 等待事件发生的超时时间（毫秒）。-1 表示无限等待，0 表示立即返回。</li></ul></li><li><strong>返回值</strong>:<ul><li>成功时返回就绪的文件描述符数量。</li><li>超时返回 0。</li><li>失败时返回 -1，并设置 <code>errno</code>。</li></ul></li></ul><p>   <strong>示例</strong>:<br>   <pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">events</span>[<span class="hljs-title">MAX_EVENTS</span>];</span><span class="hljs-type">int</span> nfds = epoll_wait(epfd, events, MAX_EVENTS, <span class="hljs-number">-1</span>);<span class="hljs-keyword">if</span> (nfds == <span class="hljs-number">-1</span>) &#123;    perror(<span class="hljs-string">&quot;epoll_wait&quot;</span>);    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>; n &lt; nfds; ++n) &#123;    <span class="hljs-keyword">if</span> (events[n].events &amp; EPOLLIN) &#123;        <span class="hljs-comment">// 处理可读事件</span>    &#125;&#125;</code></pre></p><h3 id="3-工作模式"><a href="#3-工作模式" class="headerlink" title="3. 工作模式"></a>3. <strong>工作模式</strong></h3><p>   <code>epoll</code> 具有两种主要的工作模式：</p><ul><li><strong>水平触发（Level Triggered, LT）</strong>:<ul><li>默认工作模式，类似于 <code>select</code> 和 <code>poll</code> 的行为。当文件描述符就绪时，会持续通知，直到事件被处理。</li></ul></li><li><strong>边缘触发（Edge Triggered, ET）</strong>:<ul><li>高效模式，仅当文件描述符从未就绪变为就绪时才通知一次。通常配合非阻塞 I&#x2F;O 使用，避免因未处理的事件导致高 CPU 占用。</li></ul></li></ul><h3 id="4-epoll-的优点"><a href="#4-epoll-的优点" class="headerlink" title="4. epoll 的优点"></a>4. <strong>epoll 的优点</strong></h3><ul><li><strong>高效性</strong>: <code>epoll</code> 内部使用红黑树（用于管理监控的文件描述符）和链表（用于保存待处理的就绪文件描述符），相比 <code>select</code> 和 <code>poll</code>，无需每次调用时重新遍历文件描述符列表，因此在处理大量文件描述符时性能表现更优。</li><li><strong>不受文件描述符限制</strong>: <code>select</code> 有最大文件描述符数量限制，而 <code>epoll</code> 没有这一限制，因此更适合高并发场景。</li><li><strong>事件驱动机制</strong>: 边缘触发模式下，<code>epoll</code> 仅在状态发生变化时通知用户，减少不必要的系统调用。</li></ul><h3 id="5-常见应用场景-1"><a href="#5-常见应用场景-1" class="headerlink" title="5. 常见应用场景"></a>5. <strong>常见应用场景</strong></h3><ul><li><strong>高并发网络服务器</strong>: <code>epoll</code> 常用于构建高性能网络服务器，如 Nginx、Redis 等，能高效处理大量并发连接。</li><li><strong>事件驱动的系统</strong>: 如消息队列、事件通知系统等，需要高效监控大量 I&#x2F;O 事件的场景。</li></ul><h3 id="6-示例代码"><a href="#6-示例代码" class="headerlink" title="6. 示例代码"></a>6. <strong>示例代码</strong></h3><p>   下面是一个使用 <code>epoll</code> 的简单服务器示例，展示如何使用 <code>epoll</code> 处理多个客户端连接的 I&#x2F;O 事件：<br>   <pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_EVENTS 10</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> PORT 8080</span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">int</span> server_fd, new_socket, epfd;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span>    <span class="hljs-type">int</span> addrlen = <span class="hljs-keyword">sizeof</span>(address);    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">event</span>, <span class="hljs-title">events</span>[<span class="hljs-title">MAX_EVENTS</span>];</span>    <span class="hljs-comment">// 创建监听套接字</span>    <span class="hljs-keyword">if</span> ((server_fd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>) &#123;        perror(<span class="hljs-string">&quot;socket failed&quot;</span>);        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    &#125;    address.sin_family = AF_INET;    address.sin_addr.s_addr = INADDR_ANY;    address.sin_port = htons(PORT);    <span class="hljs-keyword">if</span> (bind(server_fd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;address, <span class="hljs-keyword">sizeof</span>(address)) &lt; <span class="hljs-number">0</span>) &#123;        perror(<span class="hljs-string">&quot;bind failed&quot;</span>);        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    &#125;    <span class="hljs-keyword">if</span> (listen(server_fd, <span class="hljs-number">3</span>) &lt; <span class="hljs-number">0</span>) &#123;        perror(<span class="hljs-string">&quot;listen&quot;</span>);        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    &#125;    <span class="hljs-comment">// 创建 epoll 实例</span>    epfd = epoll_create(<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span> (epfd == <span class="hljs-number">-1</span>) &#123;        perror(<span class="hljs-string">&quot;epoll_create1&quot;</span>);        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    &#125;    <span class="hljs-comment">// 将 server_fd 添加到 epoll 实例中</span>    event.events = EPOLLIN;    event.data.fd = server_fd;    <span class="hljs-keyword">if</span> (epoll_ctl(epfd, EPOLL_CTL_ADD, server_fd, &amp;event) == <span class="hljs-number">-1</span>) &#123;        perror(<span class="hljs-string">&quot;epoll_ctl&quot;</span>);        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);    &#125;    <span class="hljs-comment">// 循环等待事件</span>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;        <span class="hljs-type">int</span> nfds = epoll_wait(epfd, events, MAX_EVENTS, <span class="hljs-number">-1</span>);        <span class="hljs-keyword">if</span> (nfds == <span class="hljs-number">-1</span>) &#123;            perror(<span class="hljs-string">&quot;epoll_wait&quot;</span>);            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>; n &lt; nfds; ++n) &#123;            <span class="hljs-keyword">if</span> (events[n].data.fd == server_fd) &#123;                <span class="hljs-comment">// 接受新的连接</span>                new_socket = accept(server_fd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;address, (<span class="hljs-type">socklen_t</span>*)&amp;addrlen);                <span class="hljs-keyword">if</span> (new_socket == <span class="hljs-number">-1</span>) &#123;                    perror(<span class="hljs-string">&quot;accept&quot;</span>);                    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);                &#125;                event.events = EPOLLIN;                event.data.fd = new_socket;                <span class="hljs-keyword">if</span> (epoll_ctl(epfd, EPOLL_CTL_ADD, new_socket, &amp;event) == <span class="hljs-number">-1</span>) &#123;                    perror(<span class="hljs-string">&quot;epoll_ctl&quot;</span>);                    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 处理已连接的客户端数据</span>                <span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;                <span class="hljs-type">int</span> bytes_read = read(events[n].data.fd, buffer, <span class="hljs-keyword">sizeof</span>(buffer));                <span class="hljs-keyword">if</span> (bytes_read == <span class="hljs-number">-1</span>) &#123;                    perror(<span class="hljs-string">&quot;read&quot;</span>);                    close(events[n].data.fd);                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bytes_read == <span class="hljs-number">0</span>) &#123;                    <span class="hljs-comment">// 客户端断开连接</span>                    close(events[n].data.fd);                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received: %s\n&quot;</span>, buffer);                    <span class="hljs-comment">// 回送数据</span>                    write(events[n].data.fd, buffer, bytes_read);                &#125;            &#125;        &#125;    &#125;    close(server_fd);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></p><h3 id="7-epoll-的缺点"><a href="#7-epoll-的缺点" class="headerlink" title="7. epoll 的缺点"></a>7. <strong>epoll 的缺点</strong></h3><ul><li><strong>仅支持 Linux</strong>: <code>epoll</code> 是 Linux 特有的系统调用，因此在跨平台开发中需要考虑兼容性问题。</li><li><strong>复杂度较高</strong>: 相较于 <code>select</code>，<code>epoll</code> 的 API 使用稍复杂，特别是在处理边缘触发模式时，需要开发者更加细致地处理 I&#x2F;O 事件。</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><p><code>epoll</code> 是 Linux 上高效的 I&#x2F;O 多路复用机制，特别适合处理大量并发连接的网络服务。通过减少系统调用和优化数据结构，<code>epoll</code> 提供了比传统的 <code>select</code> 和 <code>poll</code> 更高的性能，是现代高性能网络服务器和事件驱动系统的核心技术之一。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>return和exit</title>
      <link href="/2024/08/14/linux-return%E5%92%8Cexit/"/>
      <url>/2024/08/14/linux-return%E5%92%8Cexit/</url>
      
        <content type="html"><![CDATA[<p>在Linux多线程开发中，<code>return</code> 和 <code>exit()</code> 的作用有所不同，特别是在处理线程和进程的退出时：</p><ol><li><p><strong><code>return</code></strong>:（返回到调用者那里去）</p><ul><li><strong>在主线程中使用</strong>：如果你在主线程（即<code>main</code>函数）中使用<code>return</code>，它会导致整个程序终止，所有的线程都会结束。<code>main</code>函数的<code>return</code>值会作为进程的退出状态码。</li><li><strong>在子线程中使用</strong>：如果你在子线程中使用<code>return</code>，仅仅是退出当前线程，而不会影响其他线程或整个进程。当前线程的退出状态码会被传递给<code>pthread_join()</code>，如果其他线程调用了这个函数。</li></ul></li><li><p><strong><code>exit()</code></strong>:</p><ul><li><code>exit()</code> 是一个进程级别的退出函数。无论在主线程还是子线程中调用<code>exit()</code>，它都会终止整个进程，所有的线程都会立即被终止。进程的退出状态码会由<code>exit()</code>的参数指定。</li></ul></li><li><p><strong>总结</strong>:</p><ul><li>使用<code>return</code>可以退出当前线程，而不会影响其他线程或整个进程（在子线程中）。</li><li>使用<code>exit()</code>会强制退出整个进程，包括所有线程，因此应谨慎使用，通常只在主线程中调用。</li></ul></li></ol><p>如果你需要在子线程中退出，而不影响其他线程或进程，可以使用<code>pthread_exit()</code>来替代<code>return</code>或<code>exit()</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux-慢速系统调用被信号中断</title>
      <link href="/2024/08/13/linux-%E6%85%A2%E9%80%9F%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%A2%AB%E4%BF%A1%E5%8F%B7%E4%B8%AD%E6%96%AD/"/>
      <url>/2024/08/13/linux-%E6%85%A2%E9%80%9F%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%A2%AB%E4%BF%A1%E5%8F%B7%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<p>慢速系统调用（如 <code>read</code>、<code>write</code>、<code>accept</code>、<code>recv</code>、<code>sleep</code> 等）在某些情况下会被信号中断。当这些系统调用在等待某个事件（例如等待输入&#x2F;输出或计时器到期）时，如果接收到一个信号，并且信号处理程序执行完毕后系统调用未完成，系统调用会返回一个错误，并且 <code>errno</code> 会被设置为 <code>EINTR</code>（表示系统调用被中断）。处理这些情况的方式有几种，具体取决于应用程序的需求。</p><h3 id="1-自动重新启动系统调用"><a href="#1-自动重新启动系统调用" class="headerlink" title="1. 自动重新启动系统调用"></a>1. <strong>自动重新启动系统调用</strong></h3><p>   使用 <code>sigaction</code> 设置信号处理函数时，可以指定 <code>SA_RESTART</code> 标志，这会自动重新启动那些可以重新启动的慢速系统调用。当系统调用被信号中断后，内核会在信号处理程序返回后自动重启该系统调用。</p>   <pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sigaction</span> sa;sa.sa_handler = signal_handler;sa.sa_flags = SA_RESTART; <span class="hljs-comment">// 自动重新启动系统调用</span><span class="hljs-built_in">sigemptyset</span>(&amp;sa.sa_mask);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">sigaction</span>(SIGINT, &amp;sa, <span class="hljs-literal">nullptr</span>) == <span class="hljs-number">-1</span>) &#123;    <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;sigaction&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre><p>   <strong>注意</strong>: 并非所有系统调用都能被自动重启，只有那些被标记为“可以重启”的系统调用（例如 <code>read</code>、<code>write</code> 等）才会自动重新启动。</p><h3 id="2-手动处理-EINTR-错误"><a href="#2-手动处理-EINTR-错误" class="headerlink" title="2. 手动处理 EINTR 错误"></a>2. <strong>手动处理 <code>EINTR</code> 错误</strong></h3><p>   在某些情况下，应用程序可能希望在系统调用被中断后，决定是否重新执行系统调用。为此，你可以手动检查 <code>errno</code> 是否等于 <code>EINTR</code>，并在必要时重新执行该系统调用。</p><p>   这里是一个手动处理 <code>EINTR</code> 错误的示例：</p>   <pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">read_data</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span> </span>&#123;    <span class="hljs-type">ssize_t</span> result;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;        result = <span class="hljs-built_in">read</span>(fd, buf, count);        <span class="hljs-keyword">if</span> (result == <span class="hljs-number">-1</span>) &#123;            <span class="hljs-keyword">if</span> (errno == EINTR) &#123;                <span class="hljs-comment">// 系统调用被信号中断，重试</span>                <span class="hljs-keyword">continue</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 其他错误，处理或返回</span>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;read&quot;</span>);                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 成功读取或遇到不可恢复的错误，退出循环</span>    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre><p>   <strong>这种方法的优点</strong>是你可以在每次中断后决定是否要重新尝试调用。某些情况下，应用程序可能不希望自动重试，例如希望捕获到中断并做一些特殊的处理。</p><h3 id="3-使用非阻塞-I-O"><a href="#3-使用非阻塞-I-O" class="headerlink" title="3. 使用非阻塞 I&#x2F;O"></a>3. <strong>使用非阻塞 I&#x2F;O</strong></h3><p>   在某些场景下，你可以通过将文件描述符设置为非阻塞模式来避免因信号中断而阻塞的系统调用。这样，即使系统调用被信号中断，它也不会导致整个程序阻塞。你可以使用 <code>fcntl</code> 设置文件描述符为非阻塞模式：</p>   <pre><code class="hljs cpp"><span class="hljs-type">int</span> flags = <span class="hljs-built_in">fcntl</span>(fd, F_GETFL, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (flags == <span class="hljs-number">-1</span>) &#123;    <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fcntl&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">fcntl</span>(fd, F_SETFL, flags | O_NONBLOCK) == <span class="hljs-number">-1</span>) &#123;    <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fcntl&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;</code></pre><p>   <strong>非阻塞 I&#x2F;O 的缺点</strong>是它可能需要更多的代码来处理部分完成的 I&#x2F;O 操作，并且需要反复检查操作的完成状态。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><strong>自动重新启动系统调用</strong>：使用 <code>SA_RESTART</code> 标志，适合那些希望系统调用自动恢复的场景。</li><li><strong>手动处理 <code>EINTR</code> 错误</strong>：提供更大的灵活性，适合需要对中断做特殊处理的应用。</li><li><strong>使用非阻塞 I&#x2F;O</strong>：避免阻塞的系统调用，并使程序能够在 I&#x2F;O 操作期间做其他事情。</li></ul><p>选择哪种方法取决于你的应用需求以及希望如何处理信号中断的场景。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用SIGCHLD信号回收子进程空间</title>
      <link href="/2024/08/13/linux-%E4%BD%BF%E7%94%A8SIGCHILD%E4%BF%A1%E5%8F%B7%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%A9%BA%E9%97%B4/"/>
      <url>/2024/08/13/linux-%E4%BD%BF%E7%94%A8SIGCHILD%E4%BF%A1%E5%8F%B7%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;csignal&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sigchld_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> signum)</span> </span>&#123;    <span class="hljs-comment">// 保存和恢复 errno，防止在信号处理程序中改变 errno 导致其他代码出现意外行为</span>    <span class="hljs-type">int</span> saved_errno = errno;    <span class="hljs-comment">// 使用循环等待所有已终止的子进程</span>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;        <span class="hljs-type">pid_t</span> pid = <span class="hljs-built_in">waitpid</span>(<span class="hljs-number">-1</span>, <span class="hljs-literal">nullptr</span>, WNOHANG);                <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 子进程成功终止，进行处理</span>            std::cout &lt;&lt; <span class="hljs-string">&quot;Child process &quot;</span> &lt;&lt; pid &lt;&lt; <span class="hljs-string">&quot; terminated.&quot;</span> &lt;&lt; std::endl;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 没有已终止的子进程</span>            <span class="hljs-keyword">break</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 发生错误，检查错误类型</span>            <span class="hljs-keyword">if</span> (errno == ECHILD) &#123;                <span class="hljs-comment">// 没有更多的子进程</span>                <span class="hljs-keyword">break</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (errno == EINTR) &#123;                <span class="hljs-comment">// 调用被中断，继续循环处理</span>                <span class="hljs-keyword">continue</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 其他错误，打印错误信息</span>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;waitpid&quot;</span>);                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-comment">// 恢复 errno</span>    errno = saved_errno;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 设置 SIGCHLD 信号处理函数</span>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sigaction</span> sa;    sa.sa_handler = sigchld_handler;    sa.sa_flags = SA_RESTART | SA_NOCLDSTOP;    <span class="hljs-built_in">sigemptyset</span>(&amp;sa.sa_mask);    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sigaction</span>(SIGCHLD, &amp;sa, <span class="hljs-literal">nullptr</span>) == <span class="hljs-number">-1</span>) &#123;        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;sigaction&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-type">const</span> <span class="hljs-type">int</span> NUM_CHILDREN = <span class="hljs-number">5</span>; <span class="hljs-comment">// 要创建的子进程数量</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_CHILDREN; ++i) &#123;        <span class="hljs-type">pid_t</span> pid = fork();        <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">-1</span>) &#123;            <span class="hljs-comment">// fork 失败</span>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fork&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 子进程</span>            std::cout &lt;&lt; <span class="hljs-string">&quot;Child process &quot;</span> &lt;&lt; <span class="hljs-built_in">getpid</span>() &lt;&lt; <span class="hljs-string">&quot; started.&quot;</span> &lt;&lt; std::endl;            <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 模拟子进程执行一些工作</span>            std::cout &lt;&lt; <span class="hljs-string">&quot;Child process &quot;</span> &lt;&lt; <span class="hljs-built_in">getpid</span>() &lt;&lt; <span class="hljs-string">&quot; exiting.&quot;</span> &lt;&lt; std::endl;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 父进程</span>            std::cout &lt;&lt; <span class="hljs-string">&quot;Parent created child process &quot;</span> &lt;&lt; pid &lt;&lt; std::endl;        &#125;    &#125;    <span class="hljs-comment">// 父进程持续运行，等待所有子进程终止</span>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;        <span class="hljs-built_in">pause</span>(); <span class="hljs-comment">// 暂停父进程，等待信号到来</span>    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="关键改进"><a href="#关键改进" class="headerlink" title="关键改进"></a>关键改进</h3><ol><li><p><strong>保存和恢复 <code>errno</code></strong>:</p><ul><li>在信号处理函数中，可能会改变全局的 <code>errno</code> 变量。为了防止干扰到其他代码，首先保存 <code>errno</code>，并在信号处理函数结束时恢复它的原始值。</li></ul></li><li><p><strong>更细致的 <code>waitpid</code> 错误处理</strong>:</p><ul><li><code>waitpid</code> 可能返回 -1 表示出错，因此我们检查 <code>errno</code> 来确定错误类型。<ul><li>如果 <code>errno == ECHILD</code>，表示没有更多的子进程，此时可以退出循环。</li><li>如果 <code>errno == EINTR</code>，表示系统调用被中断，应继续循环，以确保没有遗漏的子进程。</li><li>其他任何错误都通过 <code>perror</code> 打印出来，以便调试。</li></ul></li></ul></li><li><p><strong>防止信号丢失和信号竞争条件</strong>:</p><ul><li>即使多个子进程在非常短的时间内几乎同时终止，这种循环也能够正确处理所有的终止事件，避免丢失任何信号。</li></ul></li><li><p><strong>信号掩码</strong>:</p><ul><li>使用 <code>sigemptyset(&amp;sa.sa_mask)</code> 清空信号掩码，确保在处理 <code>SIGCHLD</code> 信号时，不会阻塞其他信号的到来。</li></ul></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>通过这些改进，<code>sigchld_handler</code> 函数变得更加健壮，能够更好地处理各种边界情况和错误情况，从而确保父进程能够正确清理所有已终止的子进程，避免僵尸进程的产生。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sigaction函数</title>
      <link href="/2024/08/11/linux-sigaction/"/>
      <url>/2024/08/11/linux-sigaction/</url>
      
        <content type="html"><![CDATA[<p><code>sigaction</code> 函数用于设置信号处理函数，以及控制信号处理的行为。它比 <code>signal</code> 函数更强大，提供了更多的控制选项。下面是对 <code>sigaction</code> 函数的详细解释，并附带一个将 <code>sa_flags</code> 设置为 0 的示例。</p><h3 id="sigaction-函数原型"><a href="#sigaction-函数原型" class="headerlink" title="sigaction 函数原型"></a><code>sigaction</code> 函数原型</h3><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">sigaction</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sigaction *act, <span class="hljs-keyword">struct</span> sigaction *oldact)</span>;</code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ol><li><p><strong><code>signum</code></strong>：</p><ul><li>类型：<code>int</code></li><li>描述：要设置行为的信号编号。</li></ul></li><li><p><strong><code>act</code></strong>：</p><ul><li>类型：<code>const struct sigaction *</code></li><li>描述：指向 <code>sigaction</code> 结构体的指针，其中包含新的信号处理信息。</li><li>如果 <code>act</code> 为 <code>NULL</code>，则仅获取当前的信号处理信息，并不改变任何设置。</li></ul></li><li><p><strong><code>oldact</code></strong>：</p><ul><li>类型：<code>struct sigaction *</code></li><li>描述：指向 <code>sigaction</code> 结构体的指针，用于保存旧的信号处理信息。</li><li>如果 <code>oldact</code> 为 <code>NULL</code>，则不会保存旧的信息。</li></ul></li></ol><h3 id="sigaction-结构体"><a href="#sigaction-结构体" class="headerlink" title="sigaction 结构体"></a><code>sigaction</code> 结构体</h3><p><code>sigaction</code> 结构体定义了信号处理的各种选项：</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> &#123;</span>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span>        <span class="hljs-type">void</span> (*sa_handler)(<span class="hljs-type">int</span>);        <span class="hljs-type">void</span> (*sa_sigaction)(<span class="hljs-type">int</span>, <span class="hljs-type">siginfo_t</span> *, <span class="hljs-type">void</span> *);    &#125; sa_handler;    <span class="hljs-type">sigset_t</span> sa_mask;    <span class="hljs-type">int</span> sa_flags;    <span class="hljs-type">void</span> (*sa_restorer)(<span class="hljs-type">void</span>);&#125;;</code></pre><ul><li><p><strong><code>sa_handler</code></strong>：</p><ul><li>类型：<code>void (*)(int)</code> 或 <code>void (*)(int, siginfo_t *, void *)</code></li><li>描述：信号处理函数的指针。可以是一个简单的处理函数（<code>sa_handler</code>），也可以是一个带有更多信息的处理函数（<code>sa_sigaction</code>）。</li></ul></li><li><p><strong><code>sa_mask</code></strong>：</p><ul><li>类型：<code>sigset_t</code></li><li>描述：在信号处理函数执行期间要屏蔽的信号集合。</li></ul></li><li><p><strong><code>sa_flags</code></strong>：</p><ul><li>类型：<code>int</code></li><li>描述：标志位，用于控制信号处理的行为。</li><li>常用标志位包括：<ul><li><code>SA_NOCLDSTOP</code>：如果设置了这个标志，那么接收到 <code>SIGCHLD</code> 信号时不会停止进程。</li><li><code>SA_RESTART</code>：如果设置了这个标志，那么在信号处理函数执行完毕后，系统调用将自动重启。</li><li><code>SA_SIGINFO</code>：如果设置了这个标志，那么信号处理函数将使用 <code>sa_sigaction</code> 而不是 <code>sa_handler</code>。</li><li><code>SA_NODEFER</code>：如果设置了这个标志，那么信号处理函数执行时不会屏蔽该信号。</li><li><code>SA_ONSTACK</code>：如果设置了这个标志，那么信号处理函数将在栈段上执行。</li><li><code>SA_NOMASK</code>：如果设置了这个标志，那么信号处理函数执行时不会屏蔽该信号。</li><li><code>SA_NOCLDWAIT</code>：如果设置了这个标志，那么接收到 <code>SIGCHLD</code> 信号时不会导致进程挂起。</li></ul></li></ul></li><li><p><strong><code>sa_restorer</code></strong>：</p><ul><li>类型：<code>void (*)(void)</code></li><li>描述：此字段通常不使用。在早期系统中，它可以用于指定一个函数来恢复原始信号处理行为。</li></ul></li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul><li>如果成功，<code>sigaction</code> 函数返回 <code>0</code>。</li><li>如果失败，返回 <code>-1</code>，并设置 <code>errno</code> 表明错误原因。</li></ul><h3 id="示例：将-sa-flags-设置为-0"><a href="#示例：将-sa-flags-设置为-0" class="headerlink" title="示例：将 sa_flags 设置为 0"></a>示例：将 <code>sa_flags</code> 设置为 0</h3><p>下面是一个示例，该示例注册了一个信号处理函数来处理 <code>SIGINT</code> 信号，并将 <code>sa_flags</code> 设置为 0。</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><span class="hljs-type">void</span> <span class="hljs-title function_">signalHandler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received signal %d\n&quot;</span>, sig);&#125;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">sa</span>;</span>    sa.sa_handler = signalHandler;    sa.sa_flags = <span class="hljs-number">0</span>; <span class="hljs-comment">// 使用默认标志位</span>    sigemptyset(&amp;sa.sa_mask);    <span class="hljs-keyword">if</span> (sigaction(SIGINT, &amp;sa, <span class="hljs-literal">NULL</span>) == <span class="hljs-number">-1</span>) &#123;        perror(<span class="hljs-string">&quot;sigaction&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Waiting for SIGINT...\n&quot;</span>);    pause(); <span class="hljs-comment">// 使进程挂起，等待信号</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol><li><p><strong>信号处理函数</strong>：</p><ul><li>在这个示例中，我们定义了一个信号处理函数 <code>signalHandler</code>，它接收信号编号作为参数。</li></ul></li><li><p><strong>设置信号处理</strong>：</p><ul><li>使用 <code>sigaction</code> 函数设置信号处理行为。</li><li>我们设置了 <code>sa_flags</code> 为 0，这意味着使用默认的标志位。</li><li>我们清空了 <code>sa_mask</code>，这意味着信号处理函数执行时不会屏蔽其他信号。</li></ul></li><li><p><strong>等待信号</strong>：</p><ul><li>使用 <code>pause</code> 函数使进程挂起，等待信号。</li></ul></li></ol><h3 id="默认行为"><a href="#默认行为" class="headerlink" title="默认行为"></a>默认行为</h3><p>当 <code>sa_flags</code> 被设置为 0 时，意味着没有特殊的标志位被设置，<code>sigaction</code> 结构体将使用默认的行为。下面是默认行为的一些关键点：</p><ul><li><p><strong>信号处理函数执行期间的屏蔽</strong>：</p><ul><li>默认情况下，信号处理函数执行期间，信号会被屏蔽，直到信号处理函数返回。这是 <code>SA_RESETHAND</code> 的默认行为。<strong>这意味着如果信号处理函数执行期间收到了相同的信号，信号处理函数将不会再次被调用，直到当前的信号处理函数返回。</strong></li></ul></li><li><p><strong>系统调用重启</strong>：</p><ul><li>默认情况下，被信号中断的系统调用不会自动重启。</li><li>如果希望系统调用在信号处理函数返回后自动重启，可以设置 <code>SA_RESTART</code> 标志位。</li></ul></li><li><p><strong>信号栈</strong>：</p><ul><li>默认情况下，信号处理函数将在常规栈上执行。</li><li>如果希望信号处理函数在信号栈上执行，可以设置 <code>SA_ONSTACK</code> 标志位。</li></ul></li><li><p><strong>信号处理函数执行时的屏蔽</strong>：</p><ul><li>默认情况下，信号处理函数执行时不会屏蔽任何其他信号。</li></ul></li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>当 <code>sa_flags</code> 设置为 0 时，信号处理函数执行期间将默认屏蔽挡当前信号，直到信号处理函数返回。如果希望信号处理函数执行时不屏蔽信号，可以设置 <code>SA_NODEFER</code> 标志位。</li><li>如果希望被信号中断的系统调用自动重启，可以设置 <code>SA_RESTART</code> 标志位。</li><li>如果希望信号处理函数在信号栈上执行，可以设置 <code>SA_ONSTACK</code> 标志位。</li></ul><p>希望这些信息能帮助你更好地理解 <code>sigaction</code> 函数及其用途！如果有任何具体问题或需要进一步的帮助，请随时告诉我。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux-进程间通信</title>
      <link href="/2024/08/10/linux-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/2024/08/10/linux-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>fcntl函数</title>
      <link href="/2024/08/09/linux-fcntl%E5%87%BD%E6%95%B0/"/>
      <url>/2024/08/09/linux-fcntl%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><code>fcntl</code> 是一个在 Unix 和 Linux 系统中广泛使用的系统调用，用于操作文件描述符。这个函数提供了一种灵活的方式来控制和管理文件描述符的各种属性和行为。</p><h3 id="fcntl-函数原型"><a href="#fcntl-函数原型" class="headerlink" title="fcntl 函数原型"></a><code>fcntl</code> 函数原型</h3><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><span class="hljs-type">int</span> <span class="hljs-title function_">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, ... <span class="hljs-comment">/* arg */</span> )</span>;</code></pre><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ol><li><p><strong><code>fd</code></strong>: 文件描述符，是一个正整数，表示一个打开的文件或设备。</p></li><li><p><strong><code>cmd</code></strong>: 操作命令，用于指定要执行的操作类型。常见的命令有以下几种：</p><ul><li><strong><code>F_DUPFD</code></strong>: 复制文件描述符，返回一个新的文件描述符，该文件描述符最小为 <code>arg</code>。</li><li><strong><code>F_GETFD</code></strong>: 获取文件描述符标志（file descriptor flags），返回 <code>FD_CLOEXEC</code> 的状态。</li><li><strong><code>F_SETFD</code></strong>: 设置文件描述符标志，可以用来设置 <code>FD_CLOEXEC</code>。</li><li><strong><code>F_GETFL</code></strong>: 获取文件状态标志（file status flags），例如 <code>O_RDONLY</code>、<code>O_NONBLOCK</code> 等。</li><li><strong><code>F_SETFL</code></strong>: 设置文件状态标志，可以设置文件的访问模式（例如将文件设置为非阻塞模式 <code>O_NONBLOCK</code>）。</li><li><strong><code>F_GETLK</code></strong>: 获取文件锁的状态。</li><li><strong><code>F_SETLK</code></strong>: 设置或清除文件锁，不会阻塞。如果不能获取锁，将返回错误。</li><li><strong><code>F_SETLKW</code></strong>: 与 <code>F_SETLK</code> 类似，但会阻塞直到锁可以被设置。</li><li><strong><code>F_GETOWN</code></strong>: 获取文件的所有者（通常用于异步 I&#x2F;O 操作的通知）。</li><li><strong><code>F_SETOWN</code></strong>: 设置文件的所有者。</li></ul></li><li><p><strong><code>arg</code></strong>: 可选参数，取决于 <code>cmd</code> 的值。有些命令需要传递一个整型值或指向结构的指针作为 <code>arg</code>。</p></li></ol><h3 id="常见用法示例"><a href="#常见用法示例" class="headerlink" title="常见用法示例"></a>常见用法示例</h3><h4 id="1-复制文件描述符"><a href="#1-复制文件描述符" class="headerlink" title="1. 复制文件描述符"></a>1. 复制文件描述符</h4><pre><code class="hljs c"><span class="hljs-type">int</span> new_fd = fcntl(fd, F_DUPFD, <span class="hljs-number">0</span>);</code></pre><p>复制 <code>fd</code> 并返回一个新的文件描述符 <code>new_fd</code>，两个描述符共享同一个打开的文件&#x2F;设备。</p><h4 id="2-获取和设置文件描述符标志"><a href="#2-获取和设置文件描述符标志" class="headerlink" title="2. 获取和设置文件描述符标志"></a>2. 获取和设置文件描述符标志</h4><pre><code class="hljs c"><span class="hljs-type">int</span> flags = fcntl(fd, F_GETFD); <span class="hljs-comment">// 获取标志</span>fcntl(fd, F_SETFD, flags | FD_CLOEXEC); <span class="hljs-comment">// 设置 FD_CLOEXEC 标志</span></code></pre><p>这段代码在执行 exec 系列函数时关闭文件描述符。</p><h4 id="3-获取和设置文件状态标志"><a href="#3-获取和设置文件状态标志" class="headerlink" title="3. 获取和设置文件状态标志"></a>3. 获取和设置文件状态标志</h4><pre><code class="hljs c"><span class="hljs-type">int</span> flags = fcntl(fd, F_GETFL); <span class="hljs-comment">// 获取当前的文件状态标志</span>fcntl(fd, F_SETFL, flags | O_NONBLOCK); <span class="hljs-comment">// 将文件设置为非阻塞模式</span></code></pre><p>这段代码将文件描述符设置为非阻塞模式。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p><code>fcntl</code> 调用成功时返回正数（通常是新的文件描述符或命令的结果），如果失败则返回 <code>-1</code> 并设置 <code>errno</code> 以指示错误类型。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>fcntl</code> 是一个非常强大和灵活的系统调用，它可以用来管理文件描述符的各种属性，包括文件锁、非阻塞模式、文件描述符的复制等。它在系统编程中广泛用于控制和管理文件 I&#x2F;O 操作。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux递归遍历目录下文件,并判断文件类型</title>
      <link href="/2024/08/09/linux%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%96%87%E4%BB%B6/"/>
      <url>/2024/08/09/linux%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cerrno&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printFileType</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span></span><span class="hljs-function"></span>&#123;        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> sb;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">stat</span>(path, &amp;sb) == <span class="hljs-number">0</span>)        &#123;                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">S_ISREG</span>(sb.st_mode))                &#123;                        std::cout &lt;&lt; <span class="hljs-string">&quot;Regular file: &quot;</span> &lt;&lt; path &lt;&lt; std::endl;                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">S_ISDIR</span>(sb.st_mode))                &#123;                        std::cout &lt;&lt; <span class="hljs-string">&quot;Directory: &quot;</span> &lt;&lt; path &lt;&lt; std::endl;                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">S_ISBLK</span>(sb.st_mode))                &#123;                        std::cout &lt;&lt; <span class="hljs-string">&quot;Block device: &quot;</span> &lt;&lt; path &lt;&lt; std::endl;                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">S_ISCHR</span>(sb.st_mode))                &#123;                        std::cout &lt;&lt; <span class="hljs-string">&quot;Character device: &quot;</span> &lt;&lt; path &lt;&lt; std::endl;                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">S_ISFIFO</span>(sb.st_mode))                &#123;                        std::cout &lt;&lt; <span class="hljs-string">&quot;FIFO/pipe: &quot;</span> &lt;&lt; path &lt;&lt; std::endl;                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">S_ISSOCK</span>(sb.st_mode))                &#123;                        std::cout &lt;&lt; <span class="hljs-string">&quot;Socket: &quot;</span> &lt;&lt; path &lt;&lt; std::endl;                &#125;        &#125;        <span class="hljs-keyword">else</span>        &#123;                std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; <span class="hljs-built_in">strerror</span>(errno) &lt;&lt; std::endl;        &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">listDirectoryRecursively</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* dirPath)</span> </span>&#123;    DIR* dir;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dirent</span>* entry;    <span class="hljs-keyword">if</span> ((dir = <span class="hljs-built_in">opendir</span>(dirPath)) != <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-keyword">while</span> ((entry = <span class="hljs-built_in">readdir</span>(dir)) != <span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(entry-&gt;d_name, <span class="hljs-string">&quot;.&quot;</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(entry-&gt;d_name, <span class="hljs-string">&quot;..&quot;</span>) == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// Skip current and parent directories to avoid infinite loop</span>            &#125;            string filePath = dirPath;            <span class="hljs-keyword">if</span> (filePath.<span class="hljs-built_in">back</span>() != <span class="hljs-string">&#x27;/&#x27;</span>) &#123;                filePath += <span class="hljs-string">&quot;/&quot;</span>;            &#125;            filePath += entry-&gt;d_name;            <span class="hljs-built_in">printFileType</span>(filePath.<span class="hljs-built_in">c_str</span>());            <span class="hljs-keyword">if</span> (entry-&gt;d_type == DT_DIR) &#123;                <span class="hljs-built_in">listDirectoryRecursively</span>(filePath.<span class="hljs-built_in">c_str</span>());            &#125;        &#125;        <span class="hljs-built_in">closedir</span>(dir);    &#125; <span class="hljs-keyword">else</span> &#123;        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error opening directory: &quot;</span> &lt;&lt; <span class="hljs-built_in">strerror</span>(errno) &lt;&lt; std::endl;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;        <span class="hljs-built_in">listDirectoryRecursively</span>(<span class="hljs-string">&quot;/home/zhao/mytest&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>给CentOS7根目录所对应的分区扩容</title>
      <link href="/2024/08/09/linux%E6%89%A9%E5%AE%B9/"/>
      <url>/2024/08/09/linux%E6%89%A9%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<p>给CentOS7根目录所对应的分区扩容</p><ol><li><p>输入命令进入编辑分区模式：<br><code>fdisk /dev/sda</code></p></li><li><p>因为我的根目录对应分区为&#x2F;dev&#x2F;sda3，所以我需要先删再新建&#x2F;dev&#x2F;sda3（在编辑分区模式下执行）:<br>**输入：d 回车 **</p><p><strong>默认3 : 回车</strong><br>PS：此步骤执行完成后，千万不要保存w，否则&#x2F;dev&#x2F;sda3就真的被删除了，那样&#x2F;dev&#x2F;sda3上的数据就被清空了，根目录下所有数据就都没了。<br><strong>输入：n 回车</strong><br><strong>新建分区类型输入：p 回车</strong><br><strong>选择分区默认3：回车</strong><br>起止扇区不输入任何内容，直接回车默认，将硬盘上剩余所有容量分给sda3</p></li><li><p>保存修改然后自动退出编辑分区模式：<br><strong>输入：w 回车</strong></p></li><li><p>重启(非编辑分区模式下执行)：<br><code>reboot</code></p></li><li><p>刷新分区大小(非编辑分区模式下执行)：<br><code>resize2fs /dev/sda3</code><br>PS：因为我的&#x2F;dev&#x2F;sda3分区是ext4文件系统，所以用resize2fs &#x2F;dev&#x2F;sda3，如果是xfs文件系统，那就用xfs_growfs &#x2F;dev&#x2F;sda3。</p></li></ol><p>ext 格式：resize2fs &#x2F;dev&#x2F;sda3<br>xfs 格式：xfs_growfs &#x2F;dev&#x2F;sda3</p><ol start="6"><li>最后查看根目录是否成功扩容(非编辑分区模式下执行)：<br><code>df -h</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>google搜索语法</title>
      <link href="/2024/08/08/google%E6%90%9C%E7%B4%A2%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/08/08/google%E6%90%9C%E7%B4%A2%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>谷歌搜索提供了多种高级搜索语法和功能，帮助用户精准定位信息。以下是对谷歌搜索语法的全面介绍：</p><h3 id="1-精确短语匹配搜索"><a href="#1-精确短语匹配搜索" class="headerlink" title="1. 精确短语匹配搜索"></a>1. <strong>精确短语匹配搜索</strong></h3><ul><li><strong>语法</strong>: <code>&quot;&lt;关键词或短语&gt;&quot;</code></li><li><strong>示例</strong>: <code>&quot;machine learning&quot;</code></li><li><strong>功能</strong>: 搜索结果中只显示包含完全匹配短语的页面。这在寻找特定短语或引用时非常有用。</li></ul><h3 id="2-排除词搜索"><a href="#2-排除词搜索" class="headerlink" title="2. 排除词搜索"></a>2. <strong>排除词搜索</strong></h3><ul><li><strong>语法</strong>: <code>-&lt;排除的关键词&gt;</code></li><li><strong>示例</strong>: <code>jaguar -car</code></li><li><strong>功能</strong>: 排除包含特定词语的页面。这在寻找多义词时特别有用，例如要查找“jaguar”（美洲豹）而不是“jaguar”（汽车品牌）。</li></ul><h3 id="3-站内搜索"><a href="#3-站内搜索" class="headerlink" title="3. 站内搜索"></a>3. <strong>站内搜索</strong></h3><ul><li><strong>语法</strong>: <code>site:&lt;网站域名&gt; &lt;关键词&gt;</code></li><li><strong>示例</strong>: <code>site:wikipedia.org Python</code></li><li><strong>功能</strong>: 限定搜索范围在特定网站内。这对于查找某个网站上的特定内容非常有用。</li></ul><h3 id="4-文件类型搜索"><a href="#4-文件类型搜索" class="headerlink" title="4. 文件类型搜索"></a>4. <strong>文件类型搜索</strong></h3><ul><li><strong>语法</strong>: <code>filetype:&lt;文件扩展名&gt; &lt;关键词&gt;</code></li><li><strong>示例</strong>: <code>artificial intelligence filetype:pdf</code></li><li><strong>功能</strong>: 搜索特定文件类型的内容，如PDF、DOC、PPT等。适用于查找论文、报告或演示文档。</li></ul><h3 id="5-标题搜索"><a href="#5-标题搜索" class="headerlink" title="5. 标题搜索"></a>5. <strong>标题搜索</strong></h3><ul><li><strong>语法</strong>: <code>intitle:&lt;关键词&gt;</code></li><li><strong>示例</strong>: <code>intitle:deep learning</code></li><li><strong>功能</strong>: 只搜索页面标题中包含指定词语的页面。标题通常是页面内容的摘要，标题中出现的关键词通常代表了页面的主要内容。</li></ul><h3 id="6-URL搜索"><a href="#6-URL搜索" class="headerlink" title="6. URL搜索"></a>6. <strong>URL搜索</strong></h3><ul><li><strong>语法</strong>: <code>inurl:&lt;关键词&gt;</code></li><li><strong>示例</strong>: <code>inurl:login</code></li><li><strong>功能</strong>: 搜索URL中包含指定词语的页面。例如，可以用来查找特定页面类型，如登录页面、下载页面等。</li></ul><h3 id="7-文本内容搜索"><a href="#7-文本内容搜索" class="headerlink" title="7. 文本内容搜索"></a>7. <strong>文本内容搜索</strong></h3><ul><li><strong>语法</strong>: <code>intext:&lt;关键词&gt;</code></li><li><strong>示例</strong>: <code>intext:&quot;neural network&quot;</code></li><li><strong>功能</strong>: 只搜索页面正文中包含指定关键词的页面。这种语法适用于希望找到内容中具体提到某些词汇的页面。</li></ul><h3 id="8-锚文本搜索"><a href="#8-锚文本搜索" class="headerlink" title="8. 锚文本搜索"></a>8. <strong>锚文本搜索</strong></h3><ul><li><strong>语法</strong>: <code>inanchor:&lt;关键词&gt;</code></li><li><strong>示例</strong>: <code>inanchor:open source</code></li><li><strong>功能</strong>: 搜索锚文本（即链接文字）中包含指定关键词的页面。这有助于查找那些被特定文字链接指向的页面。</li></ul><h3 id="9-相关网站搜索"><a href="#9-相关网站搜索" class="headerlink" title="9. 相关网站搜索"></a>9. <strong>相关网站搜索</strong></h3><ul><li><strong>语法</strong>: <code>related:&lt;网站域名&gt;</code></li><li><strong>示例</strong>: <code>related:nytimes.com</code></li><li><strong>功能</strong>: 查找与指定网站内容类似的其他网站。例如，查找与《纽约时报》类似的新闻网站。</li></ul><h3 id="10-同义词搜索"><a href="#10-同义词搜索" class="headerlink" title="10. 同义词搜索"></a>10. <strong>同义词搜索</strong></h3><ul><li><strong>语法</strong>: <code>~&lt;关键词&gt;</code></li><li><strong>示例</strong>: <code>~nutrition</code></li><li><strong>功能</strong>: 搜索包含指定关键词及其同义词的页面。谷歌会自动拓展词义范围，返回相关结果。</li></ul><h3 id="11-通配符搜索"><a href="#11-通配符搜索" class="headerlink" title="11. 通配符搜索"></a>11. <strong>通配符搜索</strong></h3><ul><li><strong>语法</strong>: <code>*</code></li><li><strong>示例</strong>: <code>artificial * network</code></li><li><strong>功能</strong>: 用作占位符，用于替代未知或任意的单词。谷歌会在搜索中自动填充合适的词语。</li></ul><h3 id="12-数字范围搜索"><a href="#12-数字范围搜索" class="headerlink" title="12. 数字范围搜索"></a>12. <strong>数字范围搜索</strong></h3><ul><li><strong>语法</strong>: <code>&lt;数字1&gt;..&lt;数字2&gt;</code></li><li><strong>示例</strong>: <code>laptop $500..$1000</code></li><li><strong>功能</strong>: 搜索指定范围内的数字或价格。例如查找价格在500到1000美元之间的笔记本电脑。</li></ul><h3 id="13-OR（或）搜索"><a href="#13-OR（或）搜索" class="headerlink" title="13. OR（或）搜索"></a>13. <strong>OR（或）搜索</strong></h3><ul><li><strong>语法</strong>: <code>&lt;关键词1&gt; OR &lt;关键词2&gt;</code> 或 <code>&lt;关键词1&gt; | &lt;关键词2&gt;</code></li><li><strong>示例</strong>: <code>python OR java</code></li><li><strong>功能</strong>: 搜索包含任一关键词的页面。用于扩大搜索范围，包含可能的多种选择。</li></ul><h3 id="14-定义搜索"><a href="#14-定义搜索" class="headerlink" title="14. 定义搜索"></a>14. <strong>定义搜索</strong></h3><ul><li><strong>语法</strong>: <code>define:&lt;词语&gt;</code></li><li><strong>示例</strong>: <code>define:quantum computing</code></li><li><strong>功能</strong>: 显示指定词语的定义。谷歌会提供简短的词语解释及相关资源。</li></ul><h3 id="15-缓存页面搜索"><a href="#15-缓存页面搜索" class="headerlink" title="15. 缓存页面搜索"></a>15. <strong>缓存页面搜索</strong></h3><ul><li><strong>语法</strong>: <code>cache:&lt;网页URL&gt;</code></li><li><strong>示例</strong>: <code>cache:example.com</code></li><li><strong>功能</strong>: 显示谷歌缓存的网页快照。这对访问临时不可用或已更改的网页非常有用。</li></ul><h3 id="16-链接到页面的外部链接"><a href="#16-链接到页面的外部链接" class="headerlink" title="16. 链接到页面的外部链接"></a>16. <strong>链接到页面的外部链接</strong></h3><ul><li><strong>语法</strong>: <code>link:&lt;网页URL&gt;</code></li><li><strong>示例</strong>: <code>link:wikipedia.org</code></li><li><strong>功能</strong>: 显示链接到指定网页的其他网站。这通常用于分析页面的反向链接情况。</li></ul><h3 id="17-特定语言搜索"><a href="#17-特定语言搜索" class="headerlink" title="17. 特定语言搜索"></a>17. <strong>特定语言搜索</strong></h3><ul><li><strong>语法</strong>: <code>lang:&lt;语言代码&gt; &lt;关键词&gt;</code></li><li><strong>示例</strong>: <code>lang:es tutorial</code></li><li><strong>功能</strong>: 限定搜索范围为特定语言。例如，查找西班牙语的教程。</li></ul><h3 id="18-时间范围搜索"><a href="#18-时间范围搜索" class="headerlink" title="18. 时间范围搜索"></a>18. <strong>时间范围搜索</strong></h3><ul><li><strong>语法</strong>: 使用谷歌搜索工具栏中的“时间”选项，或通过“after:&lt;年份&gt; before:&lt;年份&gt;”语法。</li><li><strong>示例</strong>: <code>climate change after:2010 before:2020</code></li><li><strong>功能</strong>: 搜索特定时间范围内发布的内容。例如，查找2010到2020年间关于气候变化的文章。</li></ul><h3 id="19-特定位置搜索"><a href="#19-特定位置搜索" class="headerlink" title="19. 特定位置搜索"></a>19. <strong>特定位置搜索</strong></h3><ul><li><strong>语法</strong>: <code>location:&lt;地理位置&gt;</code></li><li><strong>示例</strong>: <code>best restaurants location:London</code></li><li><strong>功能</strong>: 搜索特定地理位置相关的信息。这对于查找本地信息或特定地区的新闻很有帮助。</li></ul><h3 id="20-符号识别"><a href="#20-符号识别" class="headerlink" title="20. 符号识别"></a>20. <strong>符号识别</strong></h3><ul><li><strong>示例</strong>:<ul><li><code>@</code>: 用于搜索社交媒体内容，例如 <code>@OpenAI</code></li><li><code>#</code>: 用于搜索热门话题标签，例如 <code>#AI</code></li></ul></li><li><strong>功能</strong>: 帮助查找社交媒体上的内容和趋势。</li></ul><h3 id="21-组合使用"><a href="#21-组合使用" class="headerlink" title="21. 组合使用"></a>21. <strong>组合使用</strong></h3><ul><li><strong>示例</strong>: <code>intitle:&quot;machine learning&quot; site:edu filetype:pdf</code></li><li><strong>功能</strong>: 可以将多个搜索语法组合在一起，以进行更复杂和精确的搜索。</li></ul><h3 id="22-翻译工具"><a href="#22-翻译工具" class="headerlink" title="22. 翻译工具"></a>22. <strong>翻译工具</strong></h3><ul><li><strong>语法</strong>: <code>translate &lt;词语&gt; to &lt;语言&gt;</code></li><li><strong>示例</strong>: <code>translate love to Spanish</code></li><li><strong>功能</strong>: 快速翻译单词或短语。</li></ul><h3 id="23-股票查询"><a href="#23-股票查询" class="headerlink" title="23. 股票查询"></a>23. <strong>股票查询</strong></h3><ul><li><strong>语法</strong>: <code>&lt;股票代码&gt;</code></li><li><strong>示例</strong>: <code>AAPL</code></li><li><strong>功能</strong>: 显示指定股票的最新价格和市场数据。</li></ul><h3 id="24-天气查询"><a href="#24-天气查询" class="headerlink" title="24. 天气查询"></a>24. <strong>天气查询</strong></h3><ul><li><strong>语法</strong>: <code>weather &lt;城市名&gt;</code></li><li><strong>示例</strong>: <code>weather New York</code></li><li><strong>功能</strong>: 显示指定城市的天气预报。</li></ul><h3 id="25-时间查询"><a href="#25-时间查询" class="headerlink" title="25. 时间查询"></a>25. <strong>时间查询</strong></h3><ul><li><strong>语法</strong>: <code>time &lt;城市名&gt;</code></li><li><strong>示例</strong>: <code>time Tokyo</code></li><li><strong>功能</strong>: 显示指定城市的当前时间。</li></ul><h3 id="26-计量单位换算"><a href="#26-计量单位换算" class="headerlink" title="26. 计量单位换算"></a>26. <strong>计量单位换算</strong></h3><ul><li><strong>语法</strong>: <code>&lt;数值&gt;&lt;原单位&gt; to &lt;目标单位&gt;</code></li><li><strong>示例</strong>: <code>10kg to lbs</code></li><li><strong>功能</strong>: 进行单位换算，例如重量、长度、温度等。</li></ul><h3 id="27-计算器功能"><a href="#27-计算器功能" class="headerlink" title="27. 计算器功能"></a>27. <strong>计算器功能</strong></h3><ul><li><strong>语法</strong>: 直接输入数学表达式</li><li><strong>示例</strong>: <code>2+2</code> 或 <code>sqrt(16)</code></li><li><strong>功能</strong>: 进行简单或复杂的数学计算。</li></ul><h3 id="28-航班信息"><a href="#28-航班信息" class="headerlink" title="28. 航班信息"></a>28. <strong>航班信息</strong></h3><ul><li><strong>语法</strong>: <code>&lt;航班号&gt;</code></li><li><strong>示例</strong>: <code>UA882</code></li><li><strong>功能</strong>: 显示航班的状态、时间和终点站信息。</li></ul><h3 id="29-快递包裹跟踪"><a href="#29-快递包裹跟踪" class="headerlink" title="29. 快递包裹跟踪"></a>29. <strong>快递包裹跟踪</strong></h3><ul><li><strong>语法</strong>: 直接输入追踪号</li><li><strong>示例</strong>: <code>1Z999AA10123456784</code></li><li><strong>功能</strong>: 跟踪快递包裹的状态。</li></ul><p>通过掌握这些搜索语法，你可以大大提高在谷歌上的搜索效率，快速找到所需信息。这些工具和技巧适用于不同的需求，无论是学术研究、工作查询，还是日常信息检索。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>B+树</title>
      <link href="/2024/08/08/B-%E6%A0%91/"/>
      <url>/2024/08/08/B-%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1tJ4m1w7yR/?spm_id_from=333.788&vd_source=22c6cdd1f2942942ebeae1c234b5b8f2">https://www.bilibili.com/video/BV1tJ4m1w7yR/?spm_id_from=333.788&amp;vd_source=22c6cdd1f2942942ebeae1c234b5b8f2</a></p><p><img src="/images/Snipaste_2024-08-08_17-03-42.png"></p><p>B+树是一种自平衡的树数据结构，广泛应用于数据库和文件系统等场景。它是一种N叉树（通常为B树的一种变体），具有较高的查找、插入和删除操作效率。**支持顺序查找、随机查找、范围查找。**以下是对B+树的详细介绍。</p><h3 id="B-树的基本概念"><a href="#B-树的基本概念" class="headerlink" title="B+树的基本概念"></a>B+树的基本概念</h3><ol><li><p><strong>节点结构</strong>:</p><ul><li><strong>内部节点（Internal Nodes）</strong>: 只存储索引键，不存储实际数据，每个节点包含指向子节点的指针。</li><li><strong>叶子节点（Leaf Nodes）</strong>: 存储实际数据（即关键字和数据记录），并按顺序链成一个双向链表，便于范围查询。</li><li><strong>阶（Degree）</strong>: B+树的阶（通常记为<code>m</code>）是指每个节点的最大子节点个数。每个内部节点包含<code>k</code>个键和<code>k+1</code>个指针（<code>⌈m/2⌉ ≤ k ≤ m</code>）。</li></ul></li><li><p><strong>性质</strong>:</p><ul><li>所有叶子节点在同一层。</li><li>内部节点用于导航，叶子节点存储实际数据。</li><li>内部节点包含<code>k</code>个键值，指向<code>k+1</code>个子节点。</li><li>根节点至少有两个子节点（除非是空树或只有一个节点的树）。</li><li>非根节点的子节点个数至少为<code>⌈m/2⌉</code>。</li></ul></li><li><p><strong>高度</strong>:</p><ul><li>B+树的高度一般较低，因为每个节点可以包含多个键值和指针，这使得树的高度相对较小，进而提高了查找效率。</li></ul></li></ol><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ol><li><p><strong>查找</strong>:</p><ul><li>从根节点开始，通过比较当前节点的键值，决定沿哪个子节点继续查找，直到叶子节点。</li><li>一旦到达叶子节点，便可在其中找到所需的数据。</li></ul></li><li><p><strong>插入</strong>:</p><ul><li>首先定位插入位置，即通过查找操作找到应该插入的叶子节点。</li><li>将新数据插入该叶子节点。如果节点已满，则需要进行节点分裂，并将中间值提升到父节点。如果父节点也满，则继续向上分裂，直到根节点。若根节点也分裂，树的高度增加。</li></ul></li><li><p><strong>删除</strong>:</p><ul><li>定位要删除的节点，首先通过查找操作找到目标叶子节点。</li><li>删除数据后，如果节点下溢（即子节点个数少于<code>⌈m/2⌉</code>），则需要借用兄弟节点的键值，或合并节点。如果父节点的键值因此减少，也可能需要向上调整或合并。</li></ul></li></ol><h3 id="B-树的优点"><a href="#B-树的优点" class="headerlink" title="B+树的优点"></a>B+树的优点</h3><ol><li><p><strong>范围查询高效</strong>:</p><ul><li>由于所有实际数据都在叶子节点且叶子节点通过指针相连，B+树能够非常高效地进行范围查询（例如找到某个范围内的所有值）。</li></ul></li><li><p><strong>更好的磁盘读写性能</strong>:</p><ul><li>B+树内部节点通常只存储索引，节点高度较低，使得查找路径较短，减少了磁盘I&#x2F;O次数。</li></ul></li><li><p><strong>支持批量查找和顺序访问</strong>:</p><ul><li>由于叶子节点通过链表连接，可以非常方便地进行顺序访问和批量处理。</li></ul></li><li><p><strong>稳定性</strong>:</p><ul><li>B+树的高度是平衡的，确保了所有插入、删除和查找操作的时间复杂度都是<code>O(log n)</code>。</li></ul></li></ol><h3 id="B-树与B树的区别"><a href="#B-树与B树的区别" class="headerlink" title="B+树与B树的区别"></a>B+树与B树的区别</h3><ul><li><strong>数据存储位置</strong>: B+树的数据仅存储在叶子节点中，而B树的数据既可以存储在叶子节点中，也可以存储在内部节点中。</li><li><strong>节点结构</strong>: B+树的内部节点不存储实际数据，只存储索引，而B树的内部节点可以存储数据。</li><li><strong>顺序访问</strong>: B+树叶子节点通过链表相连，支持顺序遍历，而B树没有这样的机制。</li><li><strong>树高度</strong>: B+树通常比B树更矮，因为B+树的内部节点更紧凑，且每个节点能存储更多索引。</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>数据库索引</strong>: B+树广泛用于关系型数据库的索引结构，如MySQL的InnoDB存储引擎使用B+树作为主索引和二级索引的实现方式。</li><li><strong>文件系统</strong>: B+树也用于文件系统中的元数据管理，如NTFS文件系统。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>B+树是一种高效的树结构，特别适用于需要频繁进行范围查询和顺序访问的场景。它通过将数据集中存储在叶子节点并使用链表连接叶子节点，提高了查询效率和顺序访问的性能。</p><h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p>B树，又称多路平衡查找树，B树中所有结点的孩子个数的最大值称为B树的阶，通常用m表示。一棵m阶B树或为空树，或为满足如下特性的m叉树：<br>1）树中每个结点至多有m棵子树，即至多含有m-1个关键字。<br>2）若根结点不是终端结点，则至少有两棵子树。<br>3）除根结点外的所有非叶结点至少有⌈m&#x2F;2⌉棵子树，即至少含有⌈m&#x2F;2⌉-1个关键字。<br>4）所有的叶结点都出现在同一层次上，并且不带信息（可以视为外部结点或类似于折半查找判定树的查找失败结点，实际上这些结点不存在，指向这些结点的指针为空）。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>跳表</title>
      <link href="/2024/08/07/%E8%B7%B3%E8%A1%A8/"/>
      <url>/2024/08/07/%E8%B7%B3%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV16Y411J7sT/?spm_id_from=333.337.search-card.all.click&vd_source=22c6cdd1f2942942ebeae1c234b5b8f2">https://www.bilibili.com/video/BV16Y411J7sT/?spm_id_from=333.337.search-card.all.click&amp;vd_source=22c6cdd1f2942942ebeae1c234b5b8f2</a></p><p>跳表（Skip List）是一种用于有序数据存储的数据结构，允许快速查询、插入和删除操作。跳表在很多方面与平衡树（如 AVL 树或红黑树）相似，但更简单且易于实现。它通过在链表的基础上增加多层索引来实现快速操作。</p><h3 id="跳表的基本结构"><a href="#跳表的基本结构" class="headerlink" title="跳表的基本结构"></a>跳表的基本结构</h3><p>跳表由多层链表组成，底层是一个有序的链表，每一层都是从底层链表中抽取的一些结点组成的链表。每一层链表包含的结点数量逐层减少，顶层链表通常只有一个结点。</p><h3 id="跳表的示意图"><a href="#跳表的示意图" class="headerlink" title="跳表的示意图"></a>跳表的示意图</h3><p>假设我们有一个包含整数的跳表：</p><pre><code class="hljs plaintext">Level 3:       1---------------------12----------------------Level 2:       1-------5-------9------12---------------------Level 1:       1--3----5--7----9--10--12---------------------Level 0:       1--2--3--4--5--6--7--8--9--10--11--12--13--14</code></pre><h3 id="跳表的操作"><a href="#跳表的操作" class="headerlink" title="跳表的操作"></a>跳表的操作</h3><ol><li><p><strong>查找（Search）</strong>：</p><ul><li>从顶层开始查找，从左到右移动，直到找到大于或等于目标值的结点。</li><li>如果找到目标值，查找结束；如果没有，向下一层继续查找。</li><li>在每一层，移动的步数较少，因为层级越高，结点越稀疏。</li></ul></li><li><p><strong>插入（Insert）</strong>：</p><ul><li>插入操作首先需要找到插入位置，即找到比新值小且最接近的结点。</li><li>插入结点后，决定新结点的层数（通常使用随机化方法，如抛硬币）。</li><li>将新结点插入到所有相关层的链表中。</li></ul></li><li><p><strong>删除（Delete）</strong>：</p><ul><li>删除操作首先需要找到目标结点在每一层的位置。</li><li>然后从每一层的链表中移除该结点。</li></ul></li></ol><h3 id="跳表的复杂度分析"><a href="#跳表的复杂度分析" class="headerlink" title="跳表的复杂度分析"></a>跳表的复杂度分析</h3><p>跳表的时间复杂度可以近似为 O(log n)，这是因为跳表的高度大约为 O(log n)，每层的搜索和插入操作平均需要 O(1) 的时间。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Skiplist</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> level = <span class="hljs-number">8</span>; <span class="hljs-comment">// 层数，经验值 8，太大浪费空间，因为每一个节点都要存在每一层的 next，层数越多节点数越多</span>    <span class="hljs-comment">// 定义跳表节点</span>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;        <span class="hljs-type">int</span> val; <span class="hljs-comment">// 节点值</span>        vector&lt;Node*&gt; next; <span class="hljs-comment">// 记录节点在每一层的 next，next[i] 表示当前节点第 i 层的 next</span>        <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _val) : <span class="hljs-built_in">val</span>(_val) &#123; <span class="hljs-comment">// 构造函数</span>            next.<span class="hljs-built_in">resize</span>(level, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 初始化 next 数组的大小和层数 level 相同，初始值都指向 NULL</span>        &#125;    &#125;*head; <span class="hljs-comment">// 定义头节点 head</span>    <span class="hljs-built_in">Skiplist</span>() &#123;        head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>); <span class="hljs-comment">// 初始化一个不存在的节点值 -1</span>    &#125;    ~<span class="hljs-built_in">Skiplist</span>() &#123;        <span class="hljs-keyword">delete</span> head; <span class="hljs-comment">// 析构函数删除 head</span>    &#125;    <span class="hljs-comment">// 辅助函数：找到每一层 i 小于目标值 target 的最大节点 pre[i]，最后 pre 中存的就是每一层小于 target 的最大节点</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;Node*&gt;&amp; pre)</span> </span>&#123;        <span class="hljs-keyword">auto</span> p = head; <span class="hljs-comment">// 从头节点开始遍历每一层</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = level - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- ) &#123; <span class="hljs-comment">// 从上层往下层找</span>            <span class="hljs-keyword">while</span> (p-&gt;next[i] &amp;&amp; p-&gt;next[i]-&gt;val &lt; target) p = p-&gt;next[i]; <span class="hljs-comment">// 如果当前层 i 的 next 不为空，且它的值小于 target，则 p 往后走指向这一层 p 的 next</span>            pre[i] = p; <span class="hljs-comment">// 退出 while 时说明找到了第 i 层小于 target 的最大节点就是 p</span>        &#125;    &#125;        <span class="hljs-comment">// 从跳表中查找 target</span>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> target)</span> </span>&#123;        <span class="hljs-function">vector&lt;Node*&gt; <span class="hljs-title">pre</span><span class="hljs-params">(level)</span></span>;        <span class="hljs-built_in">find</span>(target, pre); <span class="hljs-comment">// 先找到每一层 i 小于目标值 target 的最大节点 pre[i]</span>                <span class="hljs-keyword">auto</span> p = pre[<span class="hljs-number">0</span>]-&gt;next[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 因为最下层【0】的节点是全的，所以只需要判断 target 是否在第 0 层即可，而 pre[0] 正好就是小于 target 的最大节点，如果 pre[0]-&gt;next[0] 的值不是 target 说明没有这个元素</span>        <span class="hljs-keyword">return</span> p &amp;&amp; p-&gt;val == target;    &#125;        <span class="hljs-comment">// 向跳表中插入元素 num</span>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;        <span class="hljs-function">vector&lt;Node*&gt; <span class="hljs-title">pre</span><span class="hljs-params">(level)</span></span>;        <span class="hljs-built_in">find</span>(num, pre); <span class="hljs-comment">// 先找到每一层 i 小于目标值 target 的最大节点 pre[i]</span>        <span class="hljs-keyword">auto</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(num); <span class="hljs-comment">// 创建要插入的新节点</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; level; i ++ ) &#123; <span class="hljs-comment">// 遍历每一层，从下往上插入新节点</span>            p-&gt;next[i] = pre[i]-&gt;next[i]; <span class="hljs-comment">// 这两步就是单链表的插入</span>            pre[i]-&gt;next[i] = p;            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">rand</span>() % <span class="hljs-number">2</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 每一层有 50% 的概率不插入新节点</span>        &#125;    &#125;        <span class="hljs-comment">// 从跳表中删除 num</span>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;        <span class="hljs-function">vector&lt;Node*&gt; <span class="hljs-title">pre</span><span class="hljs-params">(level)</span></span>;        <span class="hljs-built_in">find</span>(num, pre); <span class="hljs-comment">// 先找到每一层 i 小于目标值 target 的最大节点 pre[i]</span>        <span class="hljs-comment">// 先判断 num 是否存在，不存在直接返回 false</span>        <span class="hljs-comment">// 第 0 层存储的是全部节点，所以只需要判断 pre[0]-&gt;next[0]（第 0 层小于 num 的最大节点的在第 0 层的 next） 是不是 num 即可</span>        <span class="hljs-keyword">auto</span> p = pre[<span class="hljs-number">0</span>]-&gt;next[<span class="hljs-number">0</span>];        <span class="hljs-keyword">if</span> (!p || p-&gt;val != num) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-comment">// 否则删除每一层的 num，如果 pre[i]-&gt;next[i] == p 说明第 i 层存在 p</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; level &amp;&amp; pre[i]-&gt;next[i] == p; i ++ ) &#123;            pre[i]-&gt;next[i] = p-&gt;next[i]; <span class="hljs-comment">// 单链表删除</span>        &#125;        <span class="hljs-keyword">delete</span> p; <span class="hljs-comment">// 删除节点 p，防止内存泄漏</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>c++11新特性</title>
      <link href="/2024/08/06/c-11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2024/08/06/c-11%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<hr><p><code>int sum&#123;&#125;;</code> 是 C++11 引入的一个特性，用于初始化变量。这里的 <code>&#123;&#125;</code> 是一种 <strong>统一初始化</strong> 语法，它在 C++11 中引入并扩展了初始化的方式。</p><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><ol><li><p><strong>值初始化</strong></p><p>当使用 <code>int sum&#123;&#125;;</code> 时，变量 <code>sum</code> 被值初始化。对于基本类型（如 <code>int</code>），值初始化将变量初始化为其默认值。在这种情况下，<code>int</code> 类型的变量将被初始化为 <code>0</code>。</p><pre><code class="hljs cpp"><span class="hljs-type">int</span> sum&#123;&#125;;  <span class="hljs-comment">// sum 被初始化为 0</span></code></pre><p>这种初始化方式可以确保变量在声明时被初始化为确定的值，防止未初始化的变量导致潜在的错误。</p></li><li><p><strong>统一初始化语法</strong></p><p>C++11 引入了统一初始化语法 <code>&#123;&#125;</code>，使得初始化各种类型的变量变得一致。这种语法的主要好处包括：</p><ul><li><strong>防止窄化转换</strong>：使用 <code>&#123;&#125;</code> 语法时，如果初始化值的类型不能隐式转换为变量的类型，编译器会报错。例如，<code>int x&#123;3.14&#125;;</code> 会导致编译错误，因为 <code>3.14</code> 是 <code>double</code> 类型，而不能隐式转换为 <code>int</code>。</li><li><strong>统一的初始化方式</strong>：不论是内置类型还是自定义类型（如类和结构体），都可以使用 <code>&#123;&#125;</code> 进行初始化，提供了一致性。</li></ul><pre><code class="hljs cpp"><span class="hljs-type">int</span> x&#123;<span class="hljs-number">5</span>&#125;;         <span class="hljs-comment">// 初始化为 5</span><span class="hljs-type">double</span> y&#123;<span class="hljs-number">3.14</span>&#125;;   <span class="hljs-comment">// 初始化为 3.14</span>std::vector&lt;<span class="hljs-type">int</span>&gt; v&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;; <span class="hljs-comment">// 初始化 std::vector</span></code></pre></li><li><p><strong>值初始化 vs. 默认初始化</strong></p><ul><li><strong>值初始化</strong>：当变量在声明时使用 <code>&#123;&#125;</code> 进行初始化时，如 <code>int sum&#123;&#125;;</code>，它将被初始化为零或相应的默认值。</li><li><strong>默认初始化</strong>：当变量未显式初始化时，它的值是未定义的（对于基本类型）。例如，<code>int x;</code> 的值是未定义的，需要显式初始化以避免使用未定义值的风险。</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>int sum&#123;&#125;;</code> 是 C++11 的统一初始化语法的一部分，它通过使用 <code>&#123;&#125;</code> 进行值初始化，将变量 <code>sum</code> 初始化为 <code>0</code>。这种语法简化了初始化的方式，并帮助防止潜在的错误。</p><hr>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>c++11类型强制转换</title>
      <link href="/2024/08/05/c-11%E7%B1%BB%E5%9E%8B%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
      <url>/2024/08/05/c-11%E7%B1%BB%E5%9E%8B%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>在C++中，有四种主要的强制类型转换运算符：<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code> 和 <code>reinterpret_cast</code>。每种类型转换运算符在编译时或运行时执行不同的检查。</p><h3 id="1-static-cast"><a href="#1-static-cast" class="headerlink" title="1. static_cast"></a>1. <code>static_cast</code></h3><p><strong>检测时刻：编译时</strong></p><ul><li>用于进行隐式转换和显式转换。</li><li>适用于基本数据类型之间的转换、类层次结构中的上行转换（从派生类到基类）和下行转换（从基类到派生类，但无运行时检查）。</li><li>编译器在编译时进行类型检查，确保转换是有效的。</li></ul><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-type">double</span> b = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(a); <span class="hljs-comment">// 编译时转换</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="2-dynamic-cast"><a href="#2-dynamic-cast" class="headerlink" title="2. dynamic_cast"></a>2. <code>dynamic_cast</code></h3><p><strong>检测时刻：运行时</strong></p><ul><li>主要用于多态类型转换（基类指针&#x2F;引用到派生类指针&#x2F;引用）。</li><li>需要基类有至少一个虚函数，以启用运行时类型信息（RTTI）。</li><li>在运行时进行类型检查，如果转换失败，指针类型返回 <code>nullptr</code>，引用类型抛出 <code>std::bad_cast</code> 异常。</li></ul><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;&#125;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">derivedFunction</span><span class="hljs-params">()</span> </span>&#123;        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived function called&quot;</span> &lt;&lt; std::endl;    &#125;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    Base* basePtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();    Derived* derivedPtr = <span class="hljs-built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);    <span class="hljs-keyword">if</span> (derivedPtr) &#123;        derivedPtr-&gt;<span class="hljs-built_in">derivedFunction</span>(); <span class="hljs-comment">// 运行时转换</span>    &#125; <span class="hljs-keyword">else</span> &#123;        std::cout &lt;&lt; <span class="hljs-string">&quot;Conversion failed&quot;</span> &lt;&lt; std::endl;    &#125;    <span class="hljs-keyword">delete</span> basePtr;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="3-const-cast"><a href="#3-const-cast" class="headerlink" title="3. const_cast"></a>3. <code>const_cast</code></h3><p><strong>检测时刻：编译时</strong></p><ul><li>用于修改类型的 <code>const</code> 或 <code>volatile</code> 属性。</li><li>主要用于将 <code>const</code> 指针或引用转换为非 <code>const</code>，反之亦然。</li><li>编译器在编译时进行类型检查。</li></ul><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-type">int</span>* p = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(&amp;a); <span class="hljs-comment">// 编译时转换</span>    *p = <span class="hljs-number">20</span>; <span class="hljs-comment">// 可能导致未定义行为</span>    <span class="hljs-comment">// 10</span>    <span class="hljs-comment">/*</span><span class="hljs-comment">    原因：因为编译器可能会将 const 变量的值内联到代码中，因此即使修改了内存中的值，输出结果仍可能显示原始的 const 值。</span><span class="hljs-comment">    */</span>    cout&lt;&lt;a&lt;&lt;endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="4-reinterpret-cast"><a href="#4-reinterpret-cast" class="headerlink" title="4. reinterpret_cast"></a>4. <code>reinterpret_cast</code></h3><p><strong>检测时刻：编译时</strong></p><ul><li>用于进行低级别的、无类型安全检查的转换。</li><li>适用于指针类型之间的转换、将指针转换为整数类型或反之。</li><li>编译器在编译时进行类型检查，但不保证转换的安全性。</li></ul><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-type">void</span>* p = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(&amp;a); <span class="hljs-comment">// 编译时转换</span>    <span class="hljs-type">int</span>* q = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(p);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>static_cast</code>：编译时检测，适用于安全的类型转换，如基本数据类型和类层次结构。</li><li><code>dynamic_cast</code>：运行时检测，适用于多态类型转换，需要运行时类型检查。</li><li><code>const_cast</code>：编译时检测，适用于修改 <code>const</code> 或 <code>volatile</code> 属性。</li><li><code>reinterpret_cast</code>：编译时检测，适用于低级别、不安全的类型转换。</li></ul><p>了解这些类型转换运算符的用途和检测时刻，有助于在编写 C++ 程序时进行适当的类型转换，确保代码的安全性和正确性。</p><h3 id="1-const-cast"><a href="#1-const-cast" class="headerlink" title="1.const_cast"></a>1.const_cast</h3><p><code>const_cast</code> 是 C++ 中的一个类型转换运算符，用于去除或添加指针或引用的常量性。与其他类型转换运算符不同，<code>const_cast</code> 只能用于修改类型的 <code>const</code> 或 <code>volatile</code> 属性。</p><h3 id="const-cast-基本语法"><a href="#const-cast-基本语法" class="headerlink" title="const_cast 基本语法"></a><code>const_cast</code> 基本语法</h3><pre><code class="hljs cpp"><span class="hljs-built_in">const_cast</span>&lt;new_type&gt;(expression)</code></pre><ul><li><code>new_type</code>：要转换成的目标类型。</li><li><code>expression</code>：要转换的表达式。</li></ul><h3 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h3><ol><li><strong>去除常量性</strong>：将 <code>const</code> 指针或引用转换为非 <code>const</code>，允许修改对象。</li><li><strong>添加常量性</strong>：将非 <code>const</code> 指针或引用转换为 <code>const</code>。</li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="去除常量性"><a href="#去除常量性" class="headerlink" title="去除常量性"></a>去除常量性</h4><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">42</span>;    <span class="hljs-comment">// 将 const int* 转换为 int*</span>    <span class="hljs-type">int</span>* p = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(&amp;n);        <span class="hljs-comment">// 修改值，尽管这种修改可能导致未定义行为</span>    *p = <span class="hljs-number">24</span>;        std::cout &lt;&lt; <span class="hljs-string">&quot;n: &quot;</span> &lt;&lt; n &lt;&lt; std::endl;      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="成员函数中去除常量性"><a href="#成员函数中去除常量性" class="headerlink" title="成员函数中去除常量性"></a>成员函数中去除常量性</h4><p>在某些情况下，成员函数被声明为 <code>const</code>，但是你需要修改成员变量。可以使用 <code>const_cast</code> 去除 <code>const</code> 属性。</p><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">value</span>(val) &#123;&#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> <span class="hljs-type">const</span> </span>&#123;        <span class="hljs-comment">// 去除 this 指针的常量性</span>        <span class="hljs-built_in">const_cast</span>&lt;MyClass*&gt;(<span class="hljs-keyword">this</span>)-&gt;value = val;    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;        <span class="hljs-keyword">return</span> value;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-type">int</span> value;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function"><span class="hljs-type">const</span> MyClass <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;    obj.<span class="hljs-built_in">setValue</span>(<span class="hljs-number">20</span>);  <span class="hljs-comment">// 修改常量对象的成员变量</span>    std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; obj.<span class="hljs-built_in">getValue</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 20</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="与库函数的兼容性"><a href="#与库函数的兼容性" class="headerlink" title="与库函数的兼容性"></a>与库函数的兼容性</h4><p>有时你需要调用一个不接受 <code>const</code> 参数的旧库函数。你可以使用 <code>const_cast</code> 去除 <code>const</code> 属性来与这样的函数兼容。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">legacyFunction</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span> </span>&#123;    std::cout &lt;&lt; <span class="hljs-string">&quot;Legacy function: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* text = <span class="hljs-string">&quot;Hello, world!&quot;</span>;    <span class="hljs-comment">// 将 const char* 转换为 char*</span>    <span class="hljs-built_in">legacyFunction</span>(<span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(text));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="添加常量性"><a href="#添加常量性" class="headerlink" title="添加常量性"></a>添加常量性</h3><p>虽然不常见，但也可以使用 <code>const_cast</code> 添加常量性。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n = <span class="hljs-number">42</span>;    <span class="hljs-comment">// 将 int* 转换为 const int*</span>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>* p = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">int</span>*&gt;(&amp;n);    <span class="hljs-comment">// 现在 p 是一个 const int*，不能通过它修改 n</span>    <span class="hljs-comment">// *p = 24;  // 错误，不能修改</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ul><li><p><strong>未定义行为</strong>：通过 <code>const_cast</code> 去除常量性并修改对象，如果对象本身是常量的（例如，定义为 <code>const</code>），这种修改会导致未定义行为。</p><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">42</span>;<span class="hljs-type">int</span>* p = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(&amp;n);*p = <span class="hljs-number">24</span>;</code></pre></li><li><p><strong>设计意图</strong>：<code>const_cast</code> 应该仅用于你确定不会破坏代码逻辑和设计意图的情况下。常量性通常用于保护数据不被意外修改，因此应谨慎使用 <code>const_cast</code>。</p></li><li><p><strong>兼容性</strong>：<code>const_cast</code> 的主要用途是为了与旧的、不使用 <code>const</code> 修饰的代码或库进行兼容。在新的代码中，尽量避免使用 <code>const_cast</code>，并采用更为安全的设计。</p></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>const_cast</code> 是一个功能强大的类型转换工具，用于在 C++ 中处理 <code>const</code> 和 <code>volatile</code> 属性。尽管它在某些场景下非常有用，但由于可能引发未定义行为，因此应谨慎使用，并尽量在设计时避免需要使用它的情况。</p><h3 id="2-static-cast"><a href="#2-static-cast" class="headerlink" title="2.static_cast"></a>2.static_cast</h3><p><code>static_cast</code> 是 C++ 中的一种类型转换运算符，用于在编译时执行类型转换。与 <code>reinterpret_cast</code> 和 <code>const_cast</code> 不同，<code>static_cast</code> 更加安全，因为它只能在特定类型之间进行转换，并且在编译时进行检查。它适用于以下几种常见的类型转换场景：</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><pre><code class="hljs cpp"><span class="hljs-built_in">static_cast</span>&lt;new_type&gt;(expression)</code></pre><ul><li><code>new_type</code>：要转换成的目标类型。</li><li><code>expression</code>：要转换的表达式。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><p><strong>基本数据类型之间的转换</strong>：</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">float</span> f = <span class="hljs-number">3.14</span>;    <span class="hljs-type">int</span> i = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(f);  <span class="hljs-comment">// 将 float 转换为 int</span>    std::cout &lt;&lt; <span class="hljs-string">&quot;i: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 i: 3</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p><strong>指针类型之间的转换</strong>：</p><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    Derived d;    Base* b = <span class="hljs-built_in">static_cast</span>&lt;Base*&gt;(&amp;d);  <span class="hljs-comment">// 将 Derived* 转换为 Base*</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p><strong>将空指针转换为其他指针类型</strong>：</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">void</span>* ptr = <span class="hljs-literal">nullptr</span>;    <span class="hljs-type">int</span>* intPtr = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(ptr);  <span class="hljs-comment">// 将 void* 转换为 int*</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p><strong>转换枚举类型</strong>：</p><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123; RED, GREEN, BLUE &#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    Color c = RED;    <span class="hljs-type">int</span> colorInt = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(c);  <span class="hljs-comment">// 将枚举类型转换为 int</span>    std::cout &lt;&lt; <span class="hljs-string">&quot;colorInt: &quot;</span> &lt;&lt; colorInt &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 colorInt: 0</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p><strong>基础类和派生类之间的转换</strong>：</p><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;&#125;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">derivedFunction</span><span class="hljs-params">()</span> </span>&#123;&#125;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    Base* b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();    Derived* d = <span class="hljs-built_in">static_cast</span>&lt;Derived*&gt;(b);  <span class="hljs-comment">// 将 Base* 转换为 Derived*</span>    d-&gt;<span class="hljs-built_in">derivedFunction</span>();  <span class="hljs-comment">// 调用派生类的方法</span>    <span class="hljs-keyword">delete</span> b;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p><strong>有意义的类型转换运算符</strong>：</p><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Complex</span>(<span class="hljs-type">double</span> real, <span class="hljs-type">double</span> imag) : <span class="hljs-built_in">real</span>(real), <span class="hljs-built_in">imag</span>(imag) &#123;&#125;    <span class="hljs-comment">// 定义转换运算符，将 Complex 转换为 double</span>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;        <span class="hljs-keyword">return</span> real;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-type">double</span> real;    <span class="hljs-type">double</span> imag;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">Complex <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)</span></span>;    <span class="hljs-type">double</span> realPart = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(c);  <span class="hljs-comment">// 使用转换运算符将 Complex 转换为 double</span>    std::cout &lt;&lt; <span class="hljs-string">&quot;realPart: &quot;</span> &lt;&lt; realPart &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 realPart: 3.0</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ol><h3 id="使用注意事项-1"><a href="#使用注意事项-1" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ul><li><p><strong>安全性</strong>：<code>static_cast</code> 进行的是编译时检查，因此相对于 <code>reinterpret_cast</code> 更为安全。但它不能用于去除 <code>const</code>、<code>volatile</code> 限定符，也不能进行不相关类型的转换。</p></li><li><p><strong>适用场景</strong>：适用于基本数据类型、指针类型、枚举类型、类层次结构中的上行转换和下行转换（必须确保安全下行）。</p></li><li><p><strong>避免未定义行为</strong>：在进行基类和派生类之间的转换时，必须确保转换是安全的，即被转换对象实际是派生类类型，否则会导致未定义行为。</p></li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><code>static_cast</code> 是 C++ 中一种安全且常用的类型转换运算符，适用于多种类型转换场景。它在编译时进行类型检查，相比 <code>reinterpret_cast</code> 和 <code>const_cast</code> 更加安全可靠。在使用时，确保理解转换的类型和语义，以避免潜在的未定义行为。</p><p><code>dynamic_cast</code> 是 C++ 中的一种类型转换运算符，用于在运行时进行安全的类型转换。它主要用于处理继承层次结构中的指针或引用，特别是在多态（polymorphism）情况下。<code>dynamic_cast</code> 通过运行时类型检查（RTTI, Run-Time Type Information）来确保转换的安全性。如果转换失败，指针类型会返回 <code>nullptr</code>，引用类型会抛出 <code>std::bad_cast</code> 异常。</p><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><pre><code class="hljs cpp"><span class="hljs-built_in">dynamic_cast</span>&lt;new_type&gt;(expression)</code></pre><ul><li><code>new_type</code>：要转换成的目标类型，必须是一个指针或引用类型。</li><li><code>expression</code>：要转换的表达式，通常是一个指向基类的指针或引用。</li></ul><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><strong>向下转换（Downcasting）</strong>：将基类指针或引用转换为派生类指针或引用。</li><li><strong>横向转换（Sidecasting）</strong>：在有多重继承的情况下，从一个基类指针转换为另一个基类指针。</li></ol><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><h4 id="向下转换"><a href="#向下转换" class="headerlink" title="向下转换"></a>向下转换</h4><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;&#125;  <span class="hljs-comment">// 必须有虚函数以启用 RTTI</span>&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">derivedFunction</span><span class="hljs-params">()</span> </span>&#123;        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived function called&quot;</span> &lt;&lt; std::endl;    &#125;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    Base* basePtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();  <span class="hljs-comment">// 基类指针指向派生类对象</span>    Derived* derivedPtr = <span class="hljs-built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);    <span class="hljs-keyword">if</span> (derivedPtr) &#123;        derivedPtr-&gt;<span class="hljs-built_in">derivedFunction</span>();  <span class="hljs-comment">// 安全调用派生类函数</span>    &#125; <span class="hljs-keyword">else</span> &#123;        std::cout &lt;&lt; <span class="hljs-string">&quot;Conversion failed&quot;</span> &lt;&lt; std::endl;    &#125;    <span class="hljs-keyword">delete</span> basePtr;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="横向转换"><a href="#横向转换" class="headerlink" title="横向转换"></a>横向转换</h4><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base1</span>() &#123;&#125;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base2</span>() &#123;&#125;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base1, <span class="hljs-keyword">public</span> Base2 &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">derivedFunction</span><span class="hljs-params">()</span> </span>&#123;        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived function called&quot;</span> &lt;&lt; std::endl;    &#125;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    Base1* base1Ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();  <span class="hljs-comment">// Base1 指针指向 Derived 对象</span>    Base2* base2Ptr = <span class="hljs-built_in">dynamic_cast</span>&lt;Base2*&gt;(base1Ptr);    <span class="hljs-keyword">if</span> (base2Ptr) &#123;        std::cout &lt;&lt; <span class="hljs-string">&quot;Successfully cast Base1* to Base2*&quot;</span> &lt;&lt; std::endl;    &#125; <span class="hljs-keyword">else</span> &#123;        std::cout &lt;&lt; <span class="hljs-string">&quot;Conversion failed&quot;</span> &lt;&lt; std::endl;    &#125;    <span class="hljs-keyword">delete</span> base1Ptr;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="引用类型的转换"><a href="#引用类型的转换" class="headerlink" title="引用类型的转换"></a>引用类型的转换</h4><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeinfo&gt;</span></span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;&#125;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">derivedFunction</span><span class="hljs-params">()</span> </span>&#123;        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived function called&quot;</span> &lt;&lt; std::endl;    &#125;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(Base&amp; baseRef)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        Derived&amp; derivedRef = <span class="hljs-built_in">dynamic_cast</span>&lt;Derived&amp;&gt;(baseRef);        derivedRef.<span class="hljs-built_in">derivedFunction</span>();    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::bad_cast&amp; e) &#123;        std::cerr &lt;&lt; <span class="hljs-string">&quot;Bad cast: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    Derived derivedObj;    Base&amp; baseRef = derivedObj;    <span class="hljs-built_in">process</span>(baseRef);  <span class="hljs-comment">// 安全转换并调用派生类方法</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="使用注意事项-2"><a href="#使用注意事项-2" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ol><li><strong>必须有虚函数</strong>：基类必须有至少一个虚函数，以便启用运行时类型信息（RTTI）。</li><li><strong>转换失败处理</strong>：在使用指针类型时，转换失败会返回 <code>nullptr</code>，在使用引用类型时，转换失败会抛出 <code>std::bad_cast</code> 异常。</li><li><strong>性能考虑</strong>：<code>dynamic_cast</code> 在运行时进行类型检查，因此相对于 <code>static_cast</code> 有一定的性能开销。</li><li><strong>避免不必要的转换</strong>：尽量设计代码避免频繁使用 <code>dynamic_cast</code>，如果可能，使用更优雅的设计模式，如策略模式或访问者模式。</li></ol><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><code>dynamic_cast</code> 是一个强大的工具，用于在 C++ 中处理继承层次结构中的类型安全转换。它通过运行时类型检查来确保转换的安全性，适用于向下转换和横向转换。理解和正确使用 <code>dynamic_cast</code> 可以帮助你编写更加健壮和安全的面向对象代码。</p><h3 id="4-reinterpret-cast-1"><a href="#4-reinterpret-cast-1" class="headerlink" title="4.reinterpret_cast"></a>4.reinterpret_cast</h3><p><code>reinterpret_cast</code> 是 C++ 中的一种类型转换运算符，用于强制转换指针、引用和其他类型之间。与其他类型转换运算符（如 <code>static_cast</code>、<code>dynamic_cast</code> 和 <code>const_cast</code>）不同，<code>reinterpret_cast</code> 可以执行非常规的类型转换，包括不安全的和未定义行为的转换，因此使用时需要特别小心。</p><h3 id="使用场景和示例"><a href="#使用场景和示例" class="headerlink" title="使用场景和示例"></a>使用场景和示例</h3><ol><li><p><strong>指针类型之间的转换</strong>：</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n = <span class="hljs-number">42</span>;    <span class="hljs-comment">// 将 int* 转换为 char*</span>    <span class="hljs-type">char</span>* p = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(&amp;n);    <span class="hljs-comment">// 输出指针 p 所指向的值</span>    std::cout &lt;&lt; *p &lt;&lt; std::endl;  <span class="hljs-comment">// 注意：输出的值依赖于系统的字节序和类型大小</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p><strong>将整数转换为指针类型</strong>：</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">intptr_t</span> addr = <span class="hljs-number">0x12345678</span>;  <span class="hljs-comment">// 整数地址</span>    <span class="hljs-comment">// 将整数转换为指针</span>    <span class="hljs-type">int</span>* p = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(addr);    <span class="hljs-comment">// 打印指针地址</span>    std::cout &lt;&lt; p &lt;&lt; std::endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p><strong>将指针转换为整数类型</strong>：</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> n = <span class="hljs-number">42</span>;    <span class="hljs-type">int</span>* p = &amp;n;    <span class="hljs-comment">// 将指针转换为整数</span>    <span class="hljs-type">intptr_t</span> addr = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">intptr_t</span>&gt;(p);    <span class="hljs-comment">// 打印整数地址</span>    std::cout &lt;&lt; std::hex &lt;&lt; addr &lt;&lt; std::endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p><strong>指向对象的指针转换为指向不同类型对象的指针</strong>：</p><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;    <span class="hljs-type">int</span> x;&#125;;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> &#123;    <span class="hljs-type">int</span> y;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    A a;    a.x = <span class="hljs-number">10</span>;    <span class="hljs-comment">// 将 A* 转换为 B*</span>    B* b = <span class="hljs-built_in">reinterpret_cast</span>&lt;B*&gt;(&amp;a);    <span class="hljs-comment">// 注意：访问 b-&gt;y 是不安全的，因为它不是 B 对象</span>    std::cout &lt;&lt; b-&gt;y &lt;&lt; std::endl;  <span class="hljs-comment">// 未定义行为</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ol><h3 id="使用注意事项-3"><a href="#使用注意事项-3" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ul><li><strong>不安全</strong>：<code>reinterpret_cast</code> 可以执行不安全的转换，这可能导致未定义行为。</li><li><strong>可移植性</strong>：<code>reinterpret_cast</code> 的行为可能依赖于具体的编译器和平台，因此使用时要考虑代码的可移植性。</li><li><strong>用途有限</strong>：应该尽量减少使用 <code>reinterpret_cast</code>，除非确实需要进行底层的、特定的类型转换，且确定不会导致未定义行为。</li></ul><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><code>reinterpret_cast</code> 是一种功能强大但危险的类型转换运算符，主要用于需要底层操作的场景。使用时应确保转换是合理且安全的，以避免潜在的未定义行为和难以调试的问题。</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>c++的const</title>
      <link href="/2024/08/05/c-%E7%9A%84const/"/>
      <url>/2024/08/05/c-%E7%9A%84const/</url>
      
        <content type="html"><![CDATA[<h1 id="C-const-关键字小结"><a href="#C-const-关键字小结" class="headerlink" title="C++ const 关键字小结"></a>C++ <code>const</code> 关键字小结</h1><p><code>const</code> 是 constant 的缩写，本意是不变的、不易改变的意思。在 C++ 中，</p><p><code>const</code> 用来修饰内置类型变量、自定义对象、成员函数、返回值、函数参数。</p><h2 id="1-C语言的-const-特点"><a href="#1-C语言的-const-特点" class="headerlink" title="1. C语言的 const 特点"></a>1. C语言的 <code>const</code> 特点</h2><p>const int a &#x3D; 10; &#x2F;&#x2F; 不要把a看成常量<br>&#x2F;&#x2F; a的本质是变量，只是只读变量</p><p>C语言的 <code>const</code> 修饰全局变量默认是（外部链接的）。</p><h3 id="fun-c"><a href="#fun-c" class="headerlink" title="fun.c"></a>fun.c</h3><pre><code class="hljs cpp"><span class="hljs-comment">// C语言的const修饰全局变量默认是（外部链接的）</span><span class="hljs-comment">// 外部链接: 其他源文件可以使用</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> num = <span class="hljs-number">100</span>; <span class="hljs-comment">// 只读的全局变量，内存放在文字常量区（内存空间只读）</span></code></pre><h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><pre><code class="hljs cpp"><span class="hljs-comment">// 对fun.c中的num进行声明(不要赋值)</span><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> num;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;num = %d\n&quot;</span>, num);    <span class="hljs-comment">// num = 200; // err num只读</span>    <span class="hljs-comment">// C语言中const修饰变量名，说明变量名为只读（用户不能通过变量名data进行赋值）</span>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> data = <span class="hljs-number">100</span>; <span class="hljs-comment">// 局部只读变量，内存在栈区（内存可读可写）</span>    <span class="hljs-comment">// data = 200; // err</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;data = %d\n&quot;</span>, data);    <span class="hljs-comment">// 但是：如果知道data的地址，可以通过地址间接地修改data所对应空间的内容</span>    <span class="hljs-type">int</span> *p = (<span class="hljs-type">int</span> *)&amp;data;    *p = <span class="hljs-number">2000</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;data = %d\n&quot;</span>, data); <span class="hljs-comment">// ok 2000</span>&#125;</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li><code>const</code> 修饰全局变量 <code>num</code>，变量名只读，内存空间在文字常量区（只读），不能通过 <code>num</code> 的地址修改空间内容。</li><li><code>const</code> 修饰局部变量 <code>data</code>，变量名只读，内存空间在栈区（可读可写），可以通过 <code>data</code> 地址间接地修改空间内容。</li></ol><h2 id="2-C-中的-const-深入理解"><a href="#2-C-中的-const-深入理解" class="headerlink" title="2. C++中的 const 深入理解"></a>2. C++中的 <code>const</code> 深入理解</h2><p><img src="/images/v2-cfd0b188ea87aeb4eed52737f45697b9_r.jpg"></p><h3 id="fun-cpp"><a href="#fun-cpp" class="headerlink" title="fun.cpp"></a>fun.cpp</h3><pre><code class="hljs cpp"><span class="hljs-comment">// const修饰的全局变量默认是内部链接（只在当前源文件有效，不能直接用于其他源文件）</span><span class="hljs-comment">// const int num = 100;</span><span class="hljs-comment">// 如果必须用在其他源文件使用只读的全局变量，必须加 extern 将 num 转换成外部链接</span><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> num = <span class="hljs-number">100</span>;</code></pre><h3 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h3><pre><code class="hljs cpp"><span class="hljs-comment">// 声明</span><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> num;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123;    <span class="hljs-type">int</span> num;    <span class="hljs-type">char</span> name[<span class="hljs-number">32</span>];&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test04</span><span class="hljs-params">()</span> </span>&#123;    cout &lt;&lt; <span class="hljs-string">&quot;全局num = &quot;</span> &lt;&lt; num &lt;&lt; endl; <span class="hljs-comment">// err 不识别num</span>    <span class="hljs-comment">// 1. C++中，对于基础类型，系统不会给data开辟空间，data放到符号表中</span>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> data = <span class="hljs-number">10</span>;    <span class="hljs-comment">// data = 100; // err 只读</span>    cout &lt;&lt; <span class="hljs-string">&quot;data = &quot;</span> &lt;&lt; data &lt;&lt; endl;    <span class="hljs-comment">// 2. C++中当对data取地址的时候，系统就会给data开辟空间</span>    <span class="hljs-type">int</span> *p = (<span class="hljs-type">int</span> *)&amp;data;    *p = <span class="hljs-number">2000</span>;    cout &lt;&lt; <span class="hljs-string">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; endl; <span class="hljs-comment">// 空间内容修改成功 2000</span>    cout &lt;&lt; <span class="hljs-string">&quot;data = &quot;</span> &lt;&lt; data &lt;&lt; endl; <span class="hljs-comment">// data 还是10，为啥？</span>    <span class="hljs-comment">// 2. 当以变量的形式初始化const修饰的变量，系统会为其开辟空间</span>    <span class="hljs-type">int</span> b = <span class="hljs-number">200</span>;    <span class="hljs-type">const</span> <span class="hljs-type">int</span> a = b; <span class="hljs-comment">// 系统直接为a开辟空间，而不会把a放入符号表中</span>    p = (<span class="hljs-type">int</span> *)&amp;a;    *p = <span class="hljs-number">3000</span>;    cout &lt;&lt; <span class="hljs-string">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; endl; <span class="hljs-comment">// 3000</span>    cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl; <span class="hljs-comment">// 3000</span>    <span class="hljs-comment">// 3. const修饰自定义数据类型（结构体、对象），系统会分配空间</span>    <span class="hljs-type">const</span> Person per = &#123;<span class="hljs-number">100</span>, <span class="hljs-string">&quot;lucy&quot;</span>&#125;;    <span class="hljs-comment">// per.num = 1000; // err</span>    cout &lt;&lt; <span class="hljs-string">&quot;num = &quot;</span> &lt;&lt; per.num &lt;&lt; <span class="hljs-string">&quot;, name = &quot;</span> &lt;&lt; per.name &lt;&lt; endl; <span class="hljs-comment">// 100 lucy</span>    Person *p1 = (Person *)&amp;per;    p1-&gt;num = <span class="hljs-number">2000</span>;    cout &lt;&lt; <span class="hljs-string">&quot;num = &quot;</span> &lt;&lt; per.num &lt;&lt; <span class="hljs-string">&quot;, name = &quot;</span> &lt;&lt; per.name &lt;&lt; endl; <span class="hljs-comment">// 2000 lucy</span>&#125;</code></pre><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><p><img src="/%5Cimages%5CSnipaste_2024-08-05_22-41-30.png"></p><p>C++的<code>const</code>总结：</p><ol><li><code>const int data = 10;</code> &#x2F;&#x2F; data先放入符号表</li><li>如果对data取地址，系统才会给data开辟空间</li><li><code>const int a = b;</code> &#x2F;&#x2F; b是变量名，系统直接给a开辟空间，而不放入符号表</li><li><code>const</code> 修饰自定义数据，系统为自定义数据开辟空间</li></ol>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cmp报错</title>
      <link href="/2024/08/05/cmp%E6%8A%A5%E9%94%99/"/>
      <url>/2024/08/05/cmp%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11智能指针</title>
      <link href="/2024/08/05/C-11%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>/2024/08/05/C-11%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h3 id="共享智能指针"><a href="#共享智能指针" class="headerlink" title="共享智能指针"></a>共享智能指针</h3><h3 id="1-shared-ptr的初始化"><a href="#1-shared-ptr的初始化" class="headerlink" title="1.shared_ptr的初始化"></a>1.shared_ptr的初始化</h3><p>共享智能指针是指多个智能指针可以同时管理同一块有效的内存，共享智能指针<code>shared_ptr</code> 是一个模板类，如果要进行初始化有三种方式：通过<strong>构造函数</strong>、<strong>make_shared辅助函数</strong>以及<strong>reset方法</strong>。共享智能指针对象初始化完毕之后就指向了要管理的那块堆内存，如果想要查看当前有多少个智能指针同时管理着这块内存可以使用共享智能指针提供的一个成员函数<code>use_count</code>，函数原型如下：</p><pre><code class="hljs c++"><span class="hljs-comment">// 管理当前对象的 shared_ptr 实例数量，或若无被管理对象则为 0。</span><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">use_count</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span></span>;</code></pre><h5 id="1-1-构造函数初始化"><a href="#1-1-构造函数初始化" class="headerlink" title="1.1 构造函数初始化"></a>1.1 构造函数初始化</h5><p>shared_ptr<T> 类模板中，提供了多种实用的构造函数, 语法格式如下:<br>shared_ptr<T> 智能指针名字(创建堆内存);</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// 使用智能指针管理一块 int 型的堆内存</span>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">520</span>))</span></span>;    cout &lt;&lt; <span class="hljs-string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl;        <span class="hljs-comment">// 使用智能指针管理一块字符数组对应的堆内存</span>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">ptr2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">12</span>])</span></span>;    cout &lt;&lt; <span class="hljs-string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr<span class="hljs-number">2.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl;        <span class="hljs-comment">// 创建智能指针对象, 不管理任何内存</span>    shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr3;    cout &lt;&lt; <span class="hljs-string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr<span class="hljs-number">3.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl;        <span class="hljs-comment">// 创建智能指针对象, 初始化为空</span>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr4</span><span class="hljs-params">(<span class="hljs-literal">nullptr</span>)</span></span>;    cout &lt;&lt; <span class="hljs-string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr<span class="hljs-number">4.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>测试代码输出的结果如下:</p><p>ptr1管理的内存引用计数: 1<br>ptr2管理的内存引用计数: 1<br>ptr3管理的内存引用计数: 0<br>ptr4管理的内存引用计数: 0</p><p>如果智能指针被初始化了一块有效内存，那么这块内存的引用计数+1，如果智能指针没有被初始化或者被初始化为<code>nullptr</code>空指针，引用计数不会+1。另外，不要使用一个原始指针初始化多个<code>shared_ptr</code>。</p><pre><code class="hljs c++"><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(p)</span></span>;    <span class="hljs-comment">//原始指针只能吃初始化一个智能指针</span><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(p)</span></span>;<span class="hljs-comment">// error, 编译不会报错, 运行会出错</span></code></pre><h5 id="1-2-通过拷贝和移动构造函数初始化"><a href="#1-2-通过拷贝和移动构造函数初始化" class="headerlink" title="1.2 通过拷贝和移动构造函数初始化"></a>1.2 通过拷贝和移动构造函数初始化</h5><p>当一个智能指针被初始化之后，就可以通过这个智能指针初始化其他新对象。在创建新对象的时候，对应的拷贝构造函数或者移动构造函数就被自动调用了。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">520</span>))</span></span>;    cout &lt;&lt; <span class="hljs-string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl;        <span class="hljs-comment">//调用拷贝构造函数</span>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr2</span><span class="hljs-params">(ptr1)</span></span>;    cout &lt;&lt; <span class="hljs-string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr<span class="hljs-number">2.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl;    shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr3 = ptr1;    cout &lt;&lt; <span class="hljs-string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr<span class="hljs-number">3.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl;        <span class="hljs-comment">//调用移动构造函数</span>    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr4</span><span class="hljs-params">(move(ptr1))</span></span>;    cout &lt;&lt; <span class="hljs-string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr<span class="hljs-number">4.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl;    std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr5 = <span class="hljs-built_in">move</span>(ptr2);    cout &lt;&lt; <span class="hljs-string">&quot;ptr5管理的内存引用计数: &quot;</span> &lt;&lt; ptr<span class="hljs-number">5.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>测试程序输入的结果：<br>ptr1管理的内存引用计数: 1<br>ptr2管理的内存引用计数: 2<br>ptr3管理的内存引用计数: 3<br>ptr4管理的内存引用计数: 3<br>ptr5管理的内存引用计数: 3</p><p>如果使用拷贝的方式初始化共享智能指针对象，这两个对象会同时管理同一块堆内存，堆内存对应的引用计数也会增加；如果使用移动的方式初始智能指针对象，只是转让了内存的所有权，管理内存的对象并不会增加，因此内存的引用计数不会变化。</p><h5 id="1-3-通过make-shared初始化"><a href="#1-3-通过make-shared初始化" class="headerlink" title="1.3 通过make_shared初始化"></a>1.3 通过make_shared初始化</h5><p>通过C++提供的make_shared() 就可以完成内存对象的创建并将其初始化给智能指针，函数原型如下：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> T, <span class="hljs-keyword">class</span>... Args &gt;</span><span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">make_shared</span><span class="hljs-params">( Args&amp;&amp;... args )</span></span>;<span class="hljs-comment">//T：模板参数的数据类型</span><span class="hljs-comment">//Args&amp;&amp;... args ：要初始化的数据，如果是通过make_shared创建对象，需按照构造函数的参数列表指定</span></code></pre><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Test</span>()     &#123;        cout &lt;&lt; <span class="hljs-string">&quot;construct Test...&quot;</span> &lt;&lt; endl;    &#125;    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> x)     &#123;        cout &lt;&lt; <span class="hljs-string">&quot;construct Test, x = &quot;</span> &lt;&lt; x &lt;&lt; endl;    &#125;    <span class="hljs-built_in">Test</span>(string str)     &#123;        cout &lt;&lt; <span class="hljs-string">&quot;construct Test, str = &quot;</span> &lt;&lt; str &lt;&lt; endl;    &#125;    ~<span class="hljs-built_in">Test</span>()    &#123;        cout &lt;&lt; <span class="hljs-string">&quot;destruct Test ...&quot;</span> &lt;&lt; endl;    &#125;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span>    shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr1 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">520</span>);    cout &lt;&lt; <span class="hljs-string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl;shared_ptr&lt;Test&gt; ptr2 = <span class="hljs-built_in">make_shared</span>&lt;Test&gt;();cout &lt;&lt; <span class="hljs-string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr<span class="hljs-number">2.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl;shared_ptr&lt;Test&gt; ptr3 = <span class="hljs-built_in">make_shared</span>&lt;Test&gt;(<span class="hljs-number">520</span>);    cout &lt;&lt; <span class="hljs-string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr<span class="hljs-number">3.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl;    shared_ptr&lt;Test&gt; ptr4 = <span class="hljs-built_in">make_shared</span>&lt;Test&gt;(<span class="hljs-string">&quot;我是要成为海贼王的男人!!!&quot;</span>);    cout &lt;&lt; <span class="hljs-string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr<span class="hljs-number">4.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>使用std::make_shared()模板函数可以完成内存地址的创建，并将最终得到的内存地址传递给共享智能指针对象管理。如果申请的内存是普通类型，通过函数的（）可完成地址的初始化，如果要创建一个类对象，函数的（）内部需要指定构造对象需要的参数，也就是类构造函数的参数。</p><h5 id="1-4-通过-reset方法初始化"><a href="#1-4-通过-reset方法初始化" class="headerlink" title="1.4 通过 reset方法初始化"></a>1.4 通过 reset方法初始化</h5><p>共享智能指针类提供的std::shared_ptr::reset方法函数原型如下：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> Y &gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">( Y* ptr )</span></span>;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> Y, <span class="hljs-keyword">class</span> Deleter &gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">( Y* ptr, Deleter d )</span></span>;<span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> Y, <span class="hljs-keyword">class</span> Deleter, <span class="hljs-keyword">class</span> Alloc &gt;</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">( Y* ptr, Deleter d, Alloc alloc )</span></span>;</code></pre><p>ptr：指向要取得所有权的对象的指针<br>d：指向要取得所有权的对象的指针<br>aloc：内部存储所用的分配器</p><p>测试代码如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span>    shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr1 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">520</span>);    shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr2 = ptr1;    shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr3 = ptr1;    shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr4 = ptr1;    cout &lt;&lt; <span class="hljs-string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr<span class="hljs-number">2.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr<span class="hljs-number">3.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr<span class="hljs-number">4.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl;    ptr<span class="hljs-number">4.</span><span class="hljs-built_in">reset</span>();    cout &lt;&lt; <span class="hljs-string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr<span class="hljs-number">2.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr<span class="hljs-number">3.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl;    cout &lt;&lt; <span class="hljs-string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr<span class="hljs-number">4.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl;        shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr5;    ptr<span class="hljs-number">5.</span><span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">250</span>));    cout &lt;&lt; <span class="hljs-string">&quot;ptr5管理的内存引用计数: &quot;</span> &lt;&lt; ptr<span class="hljs-number">5.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>测试代码输入的结果:</p><p>ptr1管理的内存引用计数: 4<br>ptr2管理的内存引用计数: 4<br>ptr3管理的内存引用计数: 4<br>ptr4管理的内存引用计数: 4</p><p>ptr1管理的内存引用计数: 3<br>ptr2管理的内存引用计数: 3<br>ptr3管理的内存引用计数: 3<br>ptr4管理的内存引用计数: 0</p><p>ptr5管理的内存引用计数: 1</p><p><strong>对于一个未初始化的共享智能指针，可以通过reset方法来初始化，当智能指针中有值的时候，调用reset会使引用计数减1。</strong></p><h5 id="1-5-获取原始指针"><a href="#1-5-获取原始指针" class="headerlink" title="1.5 获取原始指针"></a>1.5 获取原始指针</h5><p>通过智能指针可以管理一个普通变量或者对象的地址，此时原始地址就不可见了。当我们想要修改变量或者对象中的值的时候，就需要从智能指针对象中先取出数据的原始内存的地址再操作，解决方案是调用共享智能指针类提供的get()方法，其函数原型如下：</p><p><code>T* get() const noexcept;</code></p><p>测试代码如下:</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> len = <span class="hljs-number">128</span>;    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len])</span></span>;        <span class="hljs-comment">// 得到指针的原始地址</span>    <span class="hljs-type">char</span>* add = ptr.<span class="hljs-built_in">get</span>();    <span class="hljs-built_in">memset</span>(add, <span class="hljs-number">0</span>, len);    <span class="hljs-built_in">strcpy</span>(add, <span class="hljs-string">&quot;我是要成为海贼王的男人!!!&quot;</span>);    cout &lt;&lt; <span class="hljs-string">&quot;string: &quot;</span> &lt;&lt; add &lt;&lt; endl;        <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)</span></span>;    *p = <span class="hljs-number">100</span>;    cout &lt;&lt; *p.<span class="hljs-built_in">get</span>() &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; *p &lt;&lt; endl;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="指定删除器"><a href="#指定删除器" class="headerlink" title="指定删除器"></a>指定删除器</h3><p>当智能指针管理的内存对应的引用计数变为0的时候，这块内存就会被智能指针析构掉了。另外，我们在初始化智能指针的时候也可以自己指定删除动作，这个删除操作对应的函数被称之为删除器，这个删除器函数本质是一个回调函数，我们只需要进行实现，其调用是由智能指针完成的。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">// 自定义删除器函数，释放int型内存</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteIntPtr</span><span class="hljs-params">(<span class="hljs-type">int</span>* p)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">delete</span> p;    cout &lt;&lt; <span class="hljs-string">&quot;int 型内存被释放了...&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">250</span>), deleteIntPtr)</span></span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//删除器函数也可以是lambda表达式，因此代码也可以写成下面这样：</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">250</span>), [](<span class="hljs-type">int</span>* p) &#123;<span class="hljs-keyword">delete</span> p; &#125;)</span></span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>在上面的代码中，lambda表达式的参数就是智能指针管理的内存的地址，有了这个地址之后函数体内部就可以完成删除操作了。</p><p>在C++11中使用<code>shared_ptr</code>管理动态数组时，需要指定删除器，因为<code>shared_ptr</code>的<em>默认删除器不支持数组对象</em>，具体的处理代码如下：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>], [](<span class="hljs-type">int</span>* p) &#123;<span class="hljs-keyword">delete</span>[]p; &#125;)</span></span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">在删除数组内存时，除了自己编写删除器，也可以使用C++提供的default_delete&lt;T&gt;()函数作为删除器，这个函数内部的删除功能也是通过调用delete来实现的，要释放什么类型的内存就将模板类型T指定为什么类型即可。具体处理代码如下：</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>], default_delete&lt;<span class="hljs-type">int</span>[]&gt;())</span></span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>另外，我们还可以自己封装一个<code>make_shared_array</code>方法来让<code>shared_ptr</code>支持数组，代码如下:</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">make_share_array</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// 返回匿名对象</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_ptr</span>&lt;T&gt;(<span class="hljs-keyword">new</span> T[size], <span class="hljs-built_in">default_delete</span>&lt;T[]&gt;());&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr1 = <span class="hljs-built_in">make_share_array</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>);    cout &lt;&lt; ptr<span class="hljs-number">1.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl;    shared_ptr&lt;<span class="hljs-type">char</span>&gt; ptr2 = <span class="hljs-built_in">make_share_array</span>&lt;<span class="hljs-type">char</span>&gt;(<span class="hljs-number">128</span>);    cout &lt;&lt; ptr<span class="hljs-number">2.</span><span class="hljs-built_in">use_count</span>() &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><code>shared_ptr</code>使用注意事项:</p><p>1.不能使用一个原始地址初始化多个共享智能指针。</p><p>2.函数不能返回管理了this的共享智能指针对象。</p><p>3.共享智能指针不能循环引用。</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>消息验证码和数字签名</title>
      <link href="/2024/07/29/%E6%B6%88%E6%81%AF%E9%AA%8C%E8%AF%81%E7%A0%81%E5%92%8C%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
      <url>/2024/07/29/%E6%B6%88%E6%81%AF%E9%AA%8C%E8%AF%81%E7%A0%81%E5%92%8C%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2024/07/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/07/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><strong>工厂设计模式</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <span class="hljs-comment">// 引入 std 命名空间</span><span class="hljs-comment">// 抽象产品类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Product</span>() &#123;&#125;&#125;;<span class="hljs-comment">// 具体产品类 A</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProductA</span> : <span class="hljs-keyword">public</span> Product &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;        cout &lt;&lt; <span class="hljs-string">&quot;Concrete Product A&quot;</span> &lt;&lt; endl;    &#125;&#125;;<span class="hljs-comment">// 具体产品类 B</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProductB</span> : <span class="hljs-keyword">public</span> Product &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;        cout &lt;&lt; <span class="hljs-string">&quot;Concrete Product B&quot;</span> &lt;&lt; endl;    &#125;&#125;;<span class="hljs-comment">// 工厂类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-comment">// 静态方法，根据参数创建具体产品对象</span>    <span class="hljs-function"><span class="hljs-type">static</span> unique_ptr&lt;Product&gt; <span class="hljs-title">createProduct</span><span class="hljs-params">(<span class="hljs-type">char</span> type)</span> </span>&#123;        <span class="hljs-keyword">switch</span> (type) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>:                <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_unique</span>&lt;ConcreteProductA&gt;();            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;B&#x27;</span>:                <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_unique</span>&lt;ConcreteProductB&gt;();            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;        &#125;    &#125;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 使用工厂创建具体产品 A</span>    unique_ptr&lt;Product&gt; productA = Factory::<span class="hljs-built_in">createProduct</span>(<span class="hljs-string">&#x27;A&#x27;</span>);    <span class="hljs-keyword">if</span> (productA) &#123;        productA-&gt;<span class="hljs-built_in">display</span>();    &#125;    <span class="hljs-comment">// 使用工厂创建具体产品 B</span>    unique_ptr&lt;Product&gt; productB = Factory::<span class="hljs-built_in">createProduct</span>(<span class="hljs-string">&#x27;B&#x27;</span>);    <span class="hljs-keyword">if</span> (productB) &#123;        productB-&gt;<span class="hljs-built_in">display</span>();    &#125;    <span class="hljs-comment">// 使用工厂创建不存在的产品</span>    unique_ptr&lt;Product&gt; productC = Factory::<span class="hljs-built_in">createProduct</span>(<span class="hljs-string">&#x27;C&#x27;</span>);    <span class="hljs-keyword">if</span> (!productC) &#123;        cout &lt;&lt; <span class="hljs-string">&quot;Invalid product type requested.&quot;</span> &lt;&lt; endl;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux配置环境变量</title>
      <link href="/2024/07/26/Linux%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
      <url>/2024/07/26/Linux%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>当你在终端中输入 <code>echo $PATH</code> 并按回车，你会看到一系列由冒号分隔的目录路径。<code>$PATH</code> 是一个环境变量，它告诉你的系统在哪里查找可执行命令。每当你在终端输入一个命令，系统就会在 <code>$PATH</code> 变量列出的目录中搜索对应的可执行文件。</p><p><code>$PATH</code> 变量的值通常包括以下目录：</p><ul><li><code>/usr/local/bin</code>: 用户安装的本地应用程序的可执行文件。</li><li><code>/usr/bin</code>: 系统提供的标准应用程序。</li><li><code>/bin</code>: 基础的系统命令。</li><li><code>/usr/sbin</code>: 系统管理员使用的系统命令。</li><li><code>/sbin</code>: 基础的系统管理命令。</li><li><code>~/bin</code>: 用户个人的可执行文件目录。</li><li><code>/usr/local/sbin</code>: 类似于 <code>/usr/local/bin</code>，但用于系统管理命令。</li></ul><p>例如，<code>$PATH</code> 的输出可能类似于：</p><p><strong>&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;bin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;sbin:~&#x2F;bin</strong></p><p>这意味着当你在终端中输入 <code>ls</code>、<code>cd</code> 或任何其他命令时，系统会在这些目录中查找匹配的可执行文件。</p><p>你可以通过以下步骤将 &#x2F;usr&#x2F;local&#x2F;lib 添加到 PATH 环境变量中：<br>打开终端。<br>使用以下命令将 &#x2F;usr&#x2F;local&#x2F;lib 添加到当前会话的 PATH 环境变量：<br><code>export PATH=$PATH:/usr/local/lib</code><br>这只会在当前终端会话中生效。如果你关闭终端，设置将会丢失。</p><p>如果你希望永久性地将 &#x2F;usr&#x2F;local&#x2F;lib 添加到 PATH 环境变量中，你需要将上述命令添加到你的 shell 配置文件中。具体步骤如下：<br>对于 bash，编辑 ~&#x2F;.bashrc 文件：<br><code>echo &#39;export PATH=$PATH:/usr/local/lib&#39; &gt;&gt; ~/.bashrc</code></p><p>使配置文件生效：</p><p><code>source ~/.bashrc</code></p><p>这样，&#x2F;usr&#x2F;local&#x2F;lib 将被永久添加到 PATH 环境变量中，并在你每次打开新的终端会话时生效。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++11线程库</title>
      <link href="/2024/05/06/c-11%E7%BA%BF%E7%A8%8B%E5%BA%93/"/>
      <url>/2024/05/06/c-11%E7%BA%BF%E7%A8%8B%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="1-std-thread"><a href="#1-std-thread" class="headerlink" title="1. std::thread"></a>1. <code>std::thread</code></h2><p><code>std::thread</code> 类用于创建和管理线程。每个 <code>std::thread</code> 对象表示一个线程，能够执行任何可调用的对象。</p><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><ul><li><p><strong>构造函数</strong>：创建线程并执行指定的函数或可调用对象。</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_message</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> </span>&#123;    std::cout &lt;&lt; message &lt;&lt; std::endl;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(print_message, <span class="hljs-string">&quot;Hello from thread!&quot;</span>)</span></span>; <span class="hljs-comment">// 创建线程并传递参数</span>    t.<span class="hljs-built_in">join</span>(); <span class="hljs-comment">// 等待线程完成</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p><strong><code>join()</code> 和 <code>detach()</code></strong>：</p><ul><li><strong><code>join()</code></strong>：等待线程执行完成。主线程会阻塞，直到 <code>join()</code> 的线程完成。</li><li><strong><code>detach()</code></strong>：将线程分离，让它在后台继续运行，不会阻塞主线程。如果线程对象超出作用域，分离线程的资源会被自动释放，但主线程不会等待它完成。</li></ul><pre><code class="hljs cpp"><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(print_message, <span class="hljs-string">&quot;Hello from detached thread!&quot;</span>)</span></span>;t.<span class="hljs-built_in">detach</span>(); <span class="hljs-comment">// 让线程在后台运行</span></code></pre></li></ul><h2 id="2-std-this-thread"><a href="#2-std-this-thread" class="headerlink" title="2. std::this_thread"></a>2. <code>std::this_thread</code></h2><p><code>std::this_thread</code> 提供了与当前线程相关的功能。</p><h3 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h3><ul><li><p><strong><code>std::this_thread::sleep_for()</code></strong>：让当前线程休眠指定的时间段。</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 休眠 2 秒</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p><strong><code>std::this_thread::sleep_until()</code></strong>：让当前线程休眠直到指定的时间点。</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">auto</span> wake_up_time = std::chrono::steady_clock::<span class="hljs-built_in">now</span>() + std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">2</span>);    std::this_thread::<span class="hljs-built_in">sleep_until</span>(wake_up_time); <span class="hljs-comment">// 休眠直到指定时间点</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li><li><p><strong><code>std::this_thread::get_id()</code></strong>：获取当前线程的 ID。</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    std::cout &lt;&lt; <span class="hljs-string">&quot;Current thread ID: &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; std::endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul><ul><li><p><code>std::this_thread::yield()</code> 是 C++11 引入的一种函数，用于在多线程程序中使当前线程自愿让出 CPU 时间，以便其他线程可以执行。这是一个简洁而有效的方法，用于实现线程的协作和调度，尤其是在涉及线程优先级和负载均衡时。</p><h4 id="1-函数原型"><a href="#1-函数原型" class="headerlink" title="1. 函数原型"></a>1. 函数原型</h4><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">yield</span><span class="hljs-params">()</span></span>;</code></pre><ul><li><strong><code>std::this_thread::yield()</code></strong>：使当前线程让出 CPU 时间，将其从运行状态转变为就绪状态，让调度器有机会安排其他线程运行。</li></ul><h4 id="2-工作机制"><a href="#2-工作机制" class="headerlink" title="2. 工作机制"></a>2. 工作机制</h4><ul><li><p><strong>让出 CPU</strong>：调用 <code>std::this_thread::yield()</code> 让当前线程放弃它的剩余时间片，从而允许其他线程（包括优先级较高的线程或同等优先级的线程）获得 CPU 时间。线程在调用 <code>yield</code> 后会回到就绪队列等待重新调度。</p></li><li><p><strong>调度行为</strong>：<code>yield</code> 的具体行为依赖于操作系统和线程调度策略。在某些操作系统中，<code>yield</code> 可能不会立即让当前线程放弃 CPU 时间，而是在当前时间片结束时调度其他线程。在其他系统中，<code>yield</code> 可能会更快地将当前线程移到就绪队列中。</p></li></ul><h4 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h4><ul><li><p><strong>避免忙等待</strong>：在某些多线程应用中，线程可能需要等待某些条件的改变。在这种情况下，使用 <code>std::this_thread::yield()</code> 可以避免忙等待（即不断循环检查条件），从而降低 CPU 使用率并允许其他线程运行。</p></li><li><p><strong>线程协作</strong>：当线程间需要协调工作时，<code>yield</code> 可以让线程主动让出控制权，从而允许其他线程执行某些操作，尤其是在没有严格的优先级要求时。</p></li><li><p><strong>测试和调试</strong>：在调试多线程应用时，<code>yield</code> 可以帮助模拟不同的线程调度情况，观察系统的行为和性能。</p></li></ul><h4 id="4-示例代码"><a href="#4-示例代码" class="headerlink" title="4. 示例代码"></a>4. 示例代码</h4><p>下面的示例展示了如何使用 <code>std::this_thread::yield</code> 来实现简单的线程协作：</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span>std::atomic&lt;<span class="hljs-type">bool</span>&gt; flag&#123;<span class="hljs-literal">false</span>&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread1</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">while</span> (!flag.<span class="hljs-built_in">load</span>()) &#123;        std::this_thread::<span class="hljs-built_in">yield</span>(); <span class="hljs-comment">// 让出 CPU 时间</span>    &#125;    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread 1 finished&quot;</span> &lt;&lt; std::endl;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread2</span><span class="hljs-params">()</span> </span>&#123;    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">// 模拟工作</span>    flag.<span class="hljs-built_in">store</span>(<span class="hljs-literal">true</span>);    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread 2 finished&quot;</span> &lt;&lt; std::endl;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(thread1)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(thread2)</span></span>;    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>在这个示例中：</p><ul><li><code>thread1</code> 线程会在 <code>flag</code> 为 <code>false</code> 时不断调用 <code>std::this_thread::yield()</code>，让出 CPU 时间。</li><li><code>thread2</code> 线程在睡眠一秒后设置 <code>flag</code> 为 <code>true</code>，使 <code>thread1</code> 能够继续执行。</li></ul><h4 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h4><ul><li><p><strong>性能影响</strong>：<code>yield</code> 的使用可能会影响性能，特别是在高负载或高频率调用时。需要在合适的场景下使用，以避免不必要的性能开销。</p></li><li><p><strong>操作系统依赖</strong>：<code>yield</code> 的行为依赖于底层操作系统的线程调度实现，因此不同操作系统可能会有不同的行为表现。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>std::this_thread::yield</code> 是一个用于线程协作和调度的有用工具，使当前线程主动让出 CPU 时间，从而允许其他线程执行。它在多线程程序中能够有效地避免忙等待、实现线程协作，并帮助调试和测试。正确使用 <code>yield</code> 可以提高线程间的协调性，但也需要注意它对性能的潜在影响。</p></li></ul><h2 id="3-std-future-和-std-promise"><a href="#3-std-future-和-std-promise" class="headerlink" title="3. std::future 和 std::promise"></a>3. <code>std::future</code> 和 <code>std::promise</code></h2><p><code>std::future</code> 和 <code>std::promise</code> 用于异步操作的结果传递和同步。</p><h3 id="std-promise-和-std-future"><a href="#std-promise-和-std-future" class="headerlink" title="std::promise 和 std::future"></a><code>std::promise</code> 和 <code>std::future</code></h3><ul><li><p><strong><code>std::promise</code></strong>：用于设置一个值或异常，供其他线程通过 <code>std::future</code> 获取。</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">produce</span><span class="hljs-params">(std::promise&lt;<span class="hljs-type">int</span>&gt;&amp;&amp; prom)</span> </span>&#123;    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));    prom.<span class="hljs-built_in">set_value</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// 设置结果值</span>&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    std::promise&lt;<span class="hljs-type">int</span>&gt; prom;    std::future&lt;<span class="hljs-type">int</span>&gt; fut = prom.<span class="hljs-built_in">get_future</span>(); <span class="hljs-comment">// 获取 future 对象</span>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(produce, std::move(prom))</span></span>; <span class="hljs-comment">// 将 promise 移动到线程</span>    std::cout &lt;&lt; <span class="hljs-string">&quot;Waiting for result...&quot;</span> &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; fut.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 获取结果</span>    t.<span class="hljs-built_in">join</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul><p>这段代码演示了如何使用 <code>std::promise</code> 和 <code>std::future</code> 在多线程程序中传递结果。以下是对这段代码的详细解释：</p><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><ol><li><p><strong>创建 <code>std::promise</code> 对象</strong></p><pre><code class="hljs cpp">std::promise&lt;<span class="hljs-type">int</span>&gt; prom;</code></pre><p><code>std::promise&lt;int&gt;</code> 用于在线程之间传递结果。它允许一个线程设置一个值，另一个线程获取这个值。</p></li><li><p><strong>获取 <code>std::future</code> 对象</strong></p><pre><code class="hljs cpp">std::future&lt;<span class="hljs-type">int</span>&gt; fut = prom.<span class="hljs-built_in">get_future</span>();</code></pre><p>从 <code>std::promise</code> 对象中获取 <code>std::future</code> 对象。<code>std::future</code> 用于异步获取 <code>std::promise</code> 设置的值。</p></li><li><p><strong>将 <code>std::promise</code> 移动到线程中</strong></p><pre><code class="hljs cpp"><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(produce, std::move(prom))</span></span>;</code></pre><p><code>std::promise</code> 对象通过 <code>std::move</code> 被移动到新线程中执行。移动是必须的，因为 <code>std::promise</code> 对象在线程间传递时不支持拷贝。</p></li><li><p><strong>在新线程中设置值</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">produce</span><span class="hljs-params">(std::promise&lt;<span class="hljs-type">int</span>&gt;&amp;&amp; prom)</span> </span>&#123;    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));    prom.<span class="hljs-built_in">set_value</span>(<span class="hljs-number">42</span>);&#125;</code></pre><p><code>produce</code> 函数模拟一个耗时操作（通过 <code>std::this_thread::sleep_for</code>），然后使用 <code>prom.set_value(42)</code> 设置 <code>std::promise</code> 的值。这个值将被传递到 <code>std::future</code> 中。</p></li><li><p><strong>获取结果并输出</strong></p><pre><code class="hljs cpp">std::cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; fut.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl;</code></pre><p><code>fut.get()</code> 阻塞当前线程，直到 <code>std::promise</code> 设置的值可用。<code>fut.get()</code> 返回这个值，并输出到控制台。</p></li><li><p><strong>等待线程完成</strong></p><pre><code class="hljs cpp">t.<span class="hljs-built_in">join</span>();</code></pre><p><code>t.join()</code> 等待 <code>produce</code> 线程完成执行，确保程序在退出前 <code>produce</code> 线程已经执行完毕。</p></li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这段代码演示了如何使用 <code>std::promise</code> 和 <code>std::future</code> 来实现线程间的结果传递：</p><ul><li><code>std::promise</code> 用于设置一个值。</li><li><code>std::future</code> 用于获取这个值。</li><li>通过 <code>std::move</code> 将 <code>std::promise</code> 移动到线程中进行设置。</li><li>使用 <code>fut.get()</code> 获取结果并输出。</li></ul><p>这种方式在处理异步操作和线程间的结果传递时非常有用。</p><ul><li><p><strong><code>std::future</code></strong>：用于获取异步操作的结果。可以通过 <code>get()</code> 方法获取结果，或者使用 <code>wait()</code> 和 <code>wait_for()</code> 等方法等待结果的到来。</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compute_value</span><span class="hljs-params">()</span> </span>&#123;    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    std::future&lt;<span class="hljs-type">int</span>&gt; fut = std::<span class="hljs-built_in">async</span>(std::launch::async, compute_value); <span class="hljs-comment">// 异步计算</span>    std::cout &lt;&lt; <span class="hljs-string">&quot;Waiting for result...&quot;</span> &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; fut.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 获取结果</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul><h2 id="4-std-async"><a href="#4-std-async" class="headerlink" title="4. std::async"></a>4. <code>std::async</code></h2><p><code>std::async</code> 用于启动一个异步任务并返回 <code>std::future</code> 对象，可以用于获取异步操作的结果。</p><h3 id="使用-std-async"><a href="#使用-std-async" class="headerlink" title="使用 std::async"></a>使用 <code>std::async</code></h3><ul><li><p><strong><code>std::launch::async</code></strong>：强制异步执行。</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compute_value</span><span class="hljs-params">()</span> </span>&#123;    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    std::future&lt;<span class="hljs-type">int</span>&gt; fut = std::<span class="hljs-built_in">async</span>(std::launch::async, compute_value); <span class="hljs-comment">// 异步计算</span>    std::cout &lt;&lt; <span class="hljs-string">&quot;Waiting for result...&quot;</span> &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; fut.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 获取结果</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>这段代码演示了如何在 C++ 中让程序在后台异步地执行任务，并在稍后的时间获取任务的结果。我们将任务分配给一个后台线程去处理，而主线程则可以继续执行其他操作。</p><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol><li><p><strong>定义任务</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compute_value</span><span class="hljs-params">()</span> </span>&#123;    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;&#125;</code></pre><ul><li>这里定义了一个函数 <code>compute_value</code>，它模拟一个耗时的计算过程。函数内部使用 <code>std::this_thread::sleep_for</code> 暂停 1 秒钟，然后返回一个固定的结果 <code>42</code>。</li></ul></li><li><p><strong>启动异步任务</strong></p><pre><code class="hljs cpp">std::future&lt;<span class="hljs-type">int</span>&gt; fut = std::<span class="hljs-built_in">async</span>(std::launch::async, compute_value);</code></pre><ul><li>这一行代码的作用是启动一个异步任务。<code>std::async</code> 函数会创建一个后台线程来执行 <code>compute_value</code> 函数。这意味着 <code>compute_value</code> 函数会在后台运行，而不会阻塞主线程。</li><li><code>std::future&lt;int&gt; fut</code> 是用来接收这个任务的结果的。它提供了一个机制来检查任务是否完成，并获取计算结果。</li></ul></li><li><p><strong>继续执行其他操作</strong></p><pre><code class="hljs cpp">std::cout &lt;&lt; <span class="hljs-string">&quot;Waiting for result...&quot;</span> &lt;&lt; std::endl;</code></pre><ul><li>在任务运行时，主线程会继续执行其他操作。在这个例子中，它输出一条消息，表明程序正在等待计算结果。</li></ul></li><li><p><strong>获取并显示结果</strong></p><pre><code class="hljs cpp">std::cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; fut.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl;</code></pre><ul><li><code>fut.get()</code> 会阻塞主线程，直到后台任务完成并返回结果。它从后台线程获取计算结果并输出。</li><li>由于 <code>compute_value</code> 函数总是返回 <code>42</code>，所以这里输出的结果是 <code>42</code>。</li></ul></li><li><p><strong>结束程序</strong></p><pre><code class="hljs cpp"><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre><ul><li>程序的主函数结束，返回 <code>0</code> 表示程序成功执行。</li></ul></li></ol><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>异步任务</strong>：使用 <code>std::async</code> 启动一个后台线程来执行计算任务。</li><li><strong>获取结果</strong>：通过 <code>std::future</code> 对象 <code>fut</code> 获取异步计算的结果。</li><li><strong>主线程</strong>：在后台线程执行任务时，主线程可以继续进行其他操作。</li></ul><p>这样，你的程序可以同时进行计算和执行其他操作，提高了效率和响应性。</p></li><li><p><strong><code>std::launch::deferred</code></strong>：推迟执行，直到 <code>get()</code> 或 <code>wait()</code> 被调用。</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compute_value</span><span class="hljs-params">()</span> </span>&#123;    std::cout &lt;&lt; <span class="hljs-string">&quot;Computing...&quot;</span> &lt;&lt; std::endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    std::future&lt;<span class="hljs-type">int</span>&gt; fut = std::<span class="hljs-built_in">async</span>(std::launch::deferred, compute_value); <span class="hljs-comment">// 推迟执行</span>    std::cout &lt;&lt; <span class="hljs-string">&quot;Waiting for result...&quot;</span> &lt;&lt; std::endl;    std::cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; fut.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 执行并获取结果</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li><p><strong>执行时机</strong></p><ul><li><p><strong><code>std::launch::async</code></strong>: </p><ul><li>使用 <code>std::launch::async</code> 启动的任务会立即在一个新的线程中异步执行。</li><li>任务会在后台线程中运行，主线程可以继续执行其他操作，直到任务完成或被 <code>fut.get()</code> 阻塞等待结果。</li><li>在上述代码中，<code>compute_value</code> 会在后台线程中运行，主线程会立即输出 <code>&quot;Waiting for result...&quot;</code>。</li></ul></li><li><p><strong><code>std::launch::deferred</code></strong>:</p><ul><li>使用 <code>std::launch::deferred</code> 启动的任务会被推迟到调用 <code>fut.get()</code> 时才执行。</li><li>任务不会在后台线程中立即执行，而是在调用 <code>fut.get()</code> 时在主线程中执行。</li><li>在上述代码中，主线程首先输出 <code>&quot;Waiting for result...&quot;</code>，然后调用 <code>fut.get()</code> 时才开始执行 <code>compute_value</code>，并输出 <code>&quot;Computing...&quot;</code>。</li></ul></li></ul></li><li><p><strong>线程使用</strong></p><ul><li><p><strong><code>std::launch::async</code></strong>:</p><ul><li>使用新的线程来执行任务，可能会使用额外的线程资源和上下文切换开销。</li></ul></li><li><p><strong><code>std::launch::deferred</code></strong>:</p><ul><li>不会创建新线程，任务在调用 <code>fut.get()</code> 时由当前线程（主线程）执行，这样可以节省线程创建的开销。</li></ul></li></ul></li><li><p><strong>适用场景</strong></p><ul><li><p><strong><code>std::launch::async</code></strong>:</p><ul><li>适用于需要并行处理、后台计算或需要更高响应性场景。任务在后台线程中运行，可以充分利用多核处理器的优势。</li></ul></li><li><p><strong><code>std::launch::deferred</code></strong>:</p><ul><li>适用于任务可能不一定需要执行的情况，或者希望延迟任务执行直到需要结果时。避免了不必要的计算开销。</li></ul></li></ul></li></ol><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul><li><strong><code>std::launch::async</code></strong>：立即在后台线程中异步执行任务，适用于需要并发计算的情况。</li><li><strong><code>std::launch::deferred</code></strong>：推迟任务执行，直到调用 <code>fut.get()</code> 时才执行，适用于计算可能不一定需要的情况或希望延迟计算的场景。</li></ul><p>这两个选项提供了不同的任务执行策略，可以根据实际需求选择合适的方式来优化程序的性能和资源使用。</p><h4 id="std-thread-和-std-async区别："><a href="#std-thread-和-std-async区别：" class="headerlink" title="std::thread 和 std::async区别："></a><code>std::thread</code> 和 <code>std::async</code>区别：</h4><p><code>std::thread</code> 和 <code>std::async</code> 是 C++11 中用于并发编程的两种不同工具，它们在使用方式和适用场景上有一些重要区别。下面详细比较这两者的区别：</p><h3 id="std-thread"><a href="#std-thread" class="headerlink" title="std::thread"></a><code>std::thread</code></h3><ul><li><p><strong>用法</strong>: 用于直接创建和管理线程。</p></li><li><p><strong>创建线程</strong>: 通过构造 <code>std::thread</code> 对象并传递一个可调用对象（如函数、函数对象或 Lambda 表达式）来创建线程。</p></li><li><p><strong>控制线程</strong>: 需要手动管理线程的生命周期，包括启动、同步（例如使用 <code>join()</code>）和终止。</p></li><li><p><strong>线程间通信</strong>: 通常需要使用其他同步机制（如互斥量、条件变量）来处理线程间的通信和数据共享。</p></li><li><p><strong>示例</strong>:</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_message</span><span class="hljs-params">()</span> </span>&#123;    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from thread!&quot;</span> &lt;&lt; std::endl;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(print_message)</span></span>; <span class="hljs-comment">// 创建并启动线程</span>    t.<span class="hljs-built_in">join</span>(); <span class="hljs-comment">// 等待线程完成</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul><h3 id="std-async"><a href="#std-async" class="headerlink" title="std::async"></a><code>std::async</code></h3><ul><li><p><strong>用法</strong>: 用于启动异步任务，自动管理线程的生命周期。</p></li><li><p><strong>启动任务</strong>: 通过调用 <code>std::async</code> 来异步执行一个任务。可以指定任务的启动策略（如 <code>std::launch::async</code> 或 <code>std::launch::deferred</code>）。</p></li><li><p><strong>结果管理</strong>: <code>std::async</code> 返回一个 <code>std::future</code> 对象，可以用来获取异步计算的结果或处理任务完成的状态。</p></li><li><p><strong>线程间通信</strong>: <code>std::future</code> 提供了一种简单的方式来等待任务结果，并进行线程间的同步，避免了手动管理线程。</p></li><li><p><strong>示例</strong>:</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compute_value</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    std::future&lt;<span class="hljs-type">int</span>&gt; fut = std::<span class="hljs-built_in">async</span>(std::launch::async, compute_value); <span class="hljs-comment">// 异步计算</span>    std::cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; fut.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 获取结果</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></li></ul><h3 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h3><ol><li><p><strong>线程管理</strong></p><ul><li><strong><code>std::thread</code></strong>: 需要手动管理线程的创建和同步（例如使用 <code>join()</code> 确保线程完成）。你直接控制线程的生命周期和行为。</li><li><strong><code>std::async</code></strong>: 由系统自动管理线程的生命周期。你只需关注任务的提交和结果获取。任务的执行和线程的管理是透明的，减少了直接线程管理的复杂性。</li></ul></li><li><p><strong>结果获取</strong></p><ul><li><strong><code>std::thread</code></strong>: 需要通过共享变量、互斥量等机制来进行线程间的数据传递和结果获取，通常需要更多的代码和同步机制。</li><li><strong><code>std::async</code></strong>: 提供了 <code>std::future</code> 对象，通过 <code>get()</code> 方法可以方便地获取计算结果，减少了线程间同步的复杂性。</li></ul></li><li><p><strong>启动策略</strong></p><ul><li><strong><code>std::thread</code></strong>: 线程一经创建便立即执行。</li><li><strong><code>std::async</code></strong>: 允许指定启动策略。可以选择立即在后台线程中执行（<code>std::launch::async</code>），或推迟到调用 <code>get()</code> 时才执行（<code>std::launch::deferred</code>）。</li></ul></li><li><p><strong>适用场景</strong></p><ul><li><strong><code>std::thread</code></strong>: 适用于需要手动控制线程行为、需要直接与线程交互的场景。适合那些线程管理逻辑复杂的应用。</li><li><strong><code>std::async</code></strong>: 适用于需要简化异步任务管理和结果获取的场景。特别适合那些希望以简单方式执行并获取结果的任务。</li></ul></li></ol><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul><li><strong><code>std::thread</code></strong> 提供了对线程创建和管理的直接控制，适用于需要复杂线程操作的情况。</li><li><strong><code>std::async</code></strong> 提供了一个更高级的接口来简化异步任务的执行和结果获取，适合需要异步计算但不希望直接管理线程的场景。</li></ul><h2 id="5-std-atomic"><a href="#5-std-atomic" class="headerlink" title="5. std::atomic"></a>5. <code>std::atomic</code></h2><p><code>std::atomic</code> 提供原子操作，用于处理共享数据时避免数据竞争。适用于基本数据类型，如 <code>int</code>、<code>bool</code> 等。</p><h3 id="使用-std-atomic"><a href="#使用-std-atomic" class="headerlink" title="使用 std::atomic"></a>使用 <code>std::atomic</code></h3><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><span class="hljs-function">std::atomic&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">counter</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; ++i) &#123;        ++counter; <span class="hljs-comment">// 原子操作，避免数据竞争</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(increment)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(increment)</span></span>;    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();    std::cout &lt;&lt; <span class="hljs-string">&quot;Counter: &quot;</span> &lt;&lt; counter &lt;&lt; std::endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="原子操作的常用方法"><a href="#原子操作的常用方法" class="headerlink" title="原子操作的常用方法"></a>原子操作的常用方法</h3><ul><li><strong><code>store()</code></strong>：设置值。</li><li><strong><code>load()</code></strong>：获取值。</li><li><strong><code>fetch_add()</code></strong>、<strong><code>fetch_sub()</code></strong>：原子性加法和减法。</li><li><strong><code>compare_exchange_weak()</code></strong>、<strong><code>compare_exchange_strong()</code></strong>：原子比较和交换操作。</li></ul><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>C++11 的线程库引入了多个功能强大的组件来支持多线程编程：</p><ul><li><strong><code>std::thread</code></strong>：创建和管理线程。</li><li><strong><code>std::this_thread</code></strong>：提供与当前线程相关的功能，如休眠和获取线程 ID。</li><li><strong><code>std::future</code> 和 <code>std::promise</code></strong>：用于异步操作的结果传递和同步。</li><li><strong><code>std::async</code></strong>：启动异步任务并返回 <code>std::future</code> 对象。</li><li><strong><code>std::atomic</code></strong>：提供原子操作，处理多线程中的基本数据类型。</li></ul><p>这些工具和类使得 C++11 在处理并发编程时更加强大和灵活。</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>c++11互斥体</title>
      <link href="/2024/05/06/c-11%E4%BA%92%E6%96%A5%E4%BD%93/"/>
      <url>/2024/05/06/c-11%E4%BA%92%E6%96%A5%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<p>C++11引入了许多新特性来支持多线程编程，其中包括互斥体（mutex）和其他同步机制。互斥体提供了一种机制，用于**确保多个线程在同一时刻不会访问共享资源 ，从而避免数据竞争。**下面是对C++11互斥体的详细介绍。</p><h3 id="1-std-mutex"><a href="#1-std-mutex" class="headerlink" title="1. std::mutex"></a>1. <code>std::mutex</code></h3><p><code>std::mutex</code> 是 C++11 标准库中提供的用于多线程编程的基本互斥体类型。互斥体是一种同步原语，用于保护共享资源，确保同一时刻只有一个线程可以访问这些资源。</p><h4 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h4><ul><li><code>std::mutex::mutex() noexcept</code>: 构造一个互斥体。</li><li><code>std::mutex::~mutex()</code>: 析构一个互斥体。如果互斥体当前处于锁定状态，析构函数的行为是未定义的。</li></ul><h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><ul><li><code>void lock()</code><ul><li><strong>作用</strong>: 加锁互斥体。如果互斥体已经被其他线程锁定，则调用线程将阻塞，直到互斥体变为可用。</li><li><strong>异常</strong>: 如果在调用 <code>lock</code> 时互斥体已经被当前线程锁定，将导致未定义行为。</li></ul></li></ul><pre><code class="hljs cpp">std::mutex mtx;mtx.<span class="hljs-built_in">lock</span>();</code></pre><ul><li><code>bool try_lock() noexcept</code><ul><li><strong>作用</strong>: 尝试锁定互斥体。如果互斥体没有被其他线程锁定，则锁定并返回 <code>true</code>；如果互斥体已经被锁定，则立即返回 <code>false</code>。</li><li><strong>返回值</strong>: <code>true</code> 如果成功锁定互斥体；<code>false</code> 如果互斥体已经被锁定。</li></ul></li></ul><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (mtx.<span class="hljs-built_in">try_lock</span>()) &#123;    <span class="hljs-comment">// 成功锁定互斥体</span>&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 互斥体已经被其他线程锁定</span>&#125;</code></pre><ul><li><code>void unlock()</code><ul><li><strong>作用</strong>: 解锁互斥体。如果当前线程没有持有该互斥体的锁，将导致未定义行为。</li><li><strong>异常</strong>: 这个函数是 <code>noexcept</code>，不会抛出异常。</li></ul></li></ul><pre><code class="hljs cpp">mtx.<span class="hljs-built_in">unlock</span>();</code></pre><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个完整的示例，演示如何使用 <code>std::mutex</code> 及其方法来保护共享资源。</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span>std::mutex mtx;  <span class="hljs-comment">// 定义一个互斥体</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_thread_id</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;    mtx.<span class="hljs-built_in">lock</span>();  <span class="hljs-comment">// 加锁</span>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; std::endl;    mtx.<span class="hljs-built_in">unlock</span>();  <span class="hljs-comment">// 解锁</span>&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(print_thread_id, <span class="hljs-number">1</span>)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(print_thread_id, <span class="hljs-number">2</span>)</span></span>;    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>在这个例子中，<code>mtx.lock()</code> 和 <code>mtx.unlock()</code> 确保了 <code>std::cout</code> 在同一时刻只能被一个线程访问，从而避免了输出竞争条件。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><strong>死锁</strong>: 如果一个线程在没有解锁互斥体之前尝试再次锁定它，将导致死锁。因此，应该特别注意在每个加锁的地方确保有相应的解锁。</li><li><strong>异常安全性</strong>: 在加锁后的代码块中可能抛出异常，必须确保在异常抛出时能正确解锁互斥体。推荐使用 <code>std::lock_guard</code> 或 <code>std::unique_lock</code> 来自动管理锁的生命周期，避免手动管理锁的复杂性和潜在错误。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>构造函数和析构函数</strong>: 用于创建和销毁互斥体。</li><li><strong><code>lock()</code></strong>: 阻塞式加锁。</li><li><strong><code>try_lock()</code></strong>: 非阻塞式加锁。</li><li><strong><code>unlock()</code></strong>: 解锁。</li></ul><p>通过这些方法，可以在多线程编程中有效地保护共享资源，确保线程安全。</p><h3 id="2-std-lock-guard"><a href="#2-std-lock-guard" class="headerlink" title="2. std::lock_guard"></a>2. <code>std::lock_guard</code></h3><p><code>std::lock_guard</code> 是一种方便的 RAII 机制，用于<strong>自动管理互斥体的锁定和解锁</strong>。<strong>它在构造时锁定互斥体，在析构时解锁互斥体，确保互斥体在作用域结束时总是被解锁。</strong></p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span>std::mutex mtx;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_thread_id</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; std::endl;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(print_thread_id, <span class="hljs-number">1</span>)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(print_thread_id, <span class="hljs-number">2</span>)</span></span>;    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>在这个例子中，<code>std::lock_guard</code> 确保了 <code>mtx</code> 在函数 <code>print_thread_id</code> 中的整个作用域内都是锁定的。</p><p>在 C++ 中，<code>std::lock_guard</code> 是一个用于自动管理互斥体锁定和解锁的工具，确保在作用域内互斥体被正确锁定和解锁。如果你写的是：</p><pre><code class="hljs cpp"><span class="hljs-function">std::lock_guard <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;</code></pre><p>这在 C++17 及之后的标准中是正确的，因为从 C++17 开始，<code>std::lock_guard</code> 可以省略模板参数的类型推导。但是在 C++11 和 C++14 中，应该显式指定互斥体的类型。具体来说：</p><h3 id="C-11-和-C-14"><a href="#C-11-和-C-14" class="headerlink" title="C++11 和 C++14"></a>C++11 和 C++14</h3><p>在 C++11 和 C++14 中，你需要显式指定模板参数：</p><pre><code class="hljs cpp"><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;</code></pre><h3 id="C-17-及之后的标准"><a href="#C-17-及之后的标准" class="headerlink" title="C++17 及之后的标准"></a>C++17 及之后的标准</h3><p>从 C++17 开始，你可以使用类型推导来简化代码：</p><pre><code class="hljs cpp"><span class="hljs-function">std::lock_guard <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;  <span class="hljs-comment">// C++17 及之后版本</span></code></pre><p>在这个版本中，编译器可以根据构造函数的参数 <code>mtx</code> 自动推导出 <code>std::lock_guard</code> 的模板参数类型为 <code>std::mutex</code>。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>这是一个使用 <code>std::lock_guard</code> 的完整示例：</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span>std::mutex mtx;  <span class="hljs-comment">// 定义一个全局互斥体</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_thread_id</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;  <span class="hljs-comment">// C++11 和 C++14 中必须指定模板参数</span>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; std::endl;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(print_thread_id, <span class="hljs-number">1</span>)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(print_thread_id, <span class="hljs-number">2</span>)</span></span>;    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>在 C++17 中，可以写成：</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span>std::mutex mtx;  <span class="hljs-comment">// 定义一个全局互斥体</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_thread_id</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;    <span class="hljs-function">std::lock_guard <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;  <span class="hljs-comment">// C++17 中可以省略模板参数</span>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; std::endl;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(print_thread_id, <span class="hljs-number">1</span>)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(print_thread_id, <span class="hljs-number">2</span>)</span></span>;    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>C++11 和 C++14</strong>: 使用 <code>std::lock_guard&lt;std::mutex&gt;</code> 明确指定模板参数类型。</li><li><strong>C++17 及之后</strong>: 可以使用 <code>std::lock_guard</code> 并省略模板参数，编译器会进行类型推导。</li></ul><h3 id="3-std-unique-lock"><a href="#3-std-unique-lock" class="headerlink" title="3. std::unique_lock"></a>3. <code>std::unique_lock</code></h3><p><code>std::unique_lock</code> 是一种更灵活的互斥体锁管理器。与 <code>std::lock_guard</code> 相比，<code>std::unique_lock</code> 还支持<strong>延迟锁定、锁定超时和锁的解锁&#x2F;重新锁定。</strong></p><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span>std::mutex mtx;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_thread_id</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; std::endl;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(print_thread_id, <span class="hljs-number">1</span>)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(print_thread_id, <span class="hljs-number">2</span>)</span></span>;    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="延迟锁定和手动锁定-解锁"><a href="#延迟锁定和手动锁定-解锁" class="headerlink" title="延迟锁定和手动锁定&#x2F;解锁"></a>延迟锁定和手动锁定&#x2F;解锁</h4><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span>std::mutex mtx;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_thread_id</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx, std::defer_lock)</span></span>; <span class="hljs-comment">// 延迟锁定</span>    <span class="hljs-comment">// 其他操作</span>    lock.<span class="hljs-built_in">lock</span>(); <span class="hljs-comment">// 手动锁定</span>    std::cout &lt;&lt; <span class="hljs-string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; std::endl;    lock.<span class="hljs-built_in">unlock</span>(); <span class="hljs-comment">// 手动解锁</span>    <span class="hljs-comment">// 其他操作</span>&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(print_thread_id, <span class="hljs-number">1</span>)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(print_thread_id, <span class="hljs-number">2</span>)</span></span>;    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="带超时的锁定"><a href="#带超时的锁定" class="headerlink" title="带超时的锁定"></a>带超时的锁定</h4><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span>std::mutex mtx;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">try_lock_for_example</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx, std::try_to_lock)</span></span>;    <span class="hljs-keyword">if</span> (lock.<span class="hljs-built_in">owns_lock</span>()) &#123;        std::cout &lt;&lt; <span class="hljs-string">&quot;Lock acquired.&quot;</span> &lt;&lt; std::endl;    &#125; <span class="hljs-keyword">else</span> &#123;        std::cout &lt;&lt; <span class="hljs-string">&quot;Lock not acquired.&quot;</span> &lt;&lt; std::endl;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(try_lock_for_example)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(try_lock_for_example)</span></span>;    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="4-std-timed-mutex-和-std-recursive-mutex"><a href="#4-std-timed-mutex-和-std-recursive-mutex" class="headerlink" title="4. std::timed_mutex 和 std::recursive_mutex"></a>4. <code>std::timed_mutex</code> 和 <code>std::recursive_mutex</code></h3><h3 id="std-timed-mutex"><a href="#std-timed-mutex" class="headerlink" title="std::timed_mutex"></a><code>std::timed_mutex</code></h3><p><code>std::timed_mutex</code> 是一种互斥体，除了提供基本的锁定和解锁功能外，还支持带超时的锁定操作。</p><h4 id="成员函数-1"><a href="#成员函数-1" class="headerlink" title="成员函数"></a>成员函数</h4><ul><li><code>void lock()</code><ul><li><strong>作用</strong>: 加锁互斥体。如果互斥体已经被其他线程锁定，则调用线程将阻塞，直到互斥体变为可用。</li><li><strong>异常</strong>: 如果在调用 <code>lock</code> 时互斥体已经被当前线程锁定，将导致未定义行为。</li></ul></li></ul><pre><code class="hljs cpp">std::timed_mutex tmtx;tmtx.<span class="hljs-built_in">lock</span>();</code></pre><ul><li><code>bool try_lock() noexcept</code><ul><li><strong>作用</strong>: 尝试锁定互斥体。如果互斥体没有被其他线程锁定，则锁定并返回 <code>true</code>；如果互斥体已经被锁定，则立即返回 <code>false</code>。</li><li><strong>返回值</strong>: <code>true</code> 如果成功锁定互斥体；<code>false</code> 如果互斥体已经被锁定。</li></ul></li></ul><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (tmtx.<span class="hljs-built_in">try_lock</span>()) &#123;    <span class="hljs-comment">// 成功锁定互斥体</span>&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 互斥体已经被其他线程锁定</span>&#125;</code></pre><ul><li><code>bool try_lock_for(const std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time)</code><ul><li><strong>作用</strong>: 尝试锁定互斥体，直到指定的相对时间间隔过去。如果互斥体在这段时间内变为可用，则锁定并返回 <code>true</code>；如果超时，则返回 <code>false</code>。</li><li><strong>参数</strong>: <code>rel_time</code> 指定的时间间隔。</li></ul></li></ul><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (tmtx.<span class="hljs-built_in">try_lock_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>))) &#123;    <span class="hljs-comment">// 成功锁定互斥体</span>&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 超时</span>&#125;</code></pre><ul><li><code>bool try_lock_until(const std::chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)</code><ul><li><strong>作用</strong>: 尝试锁定互斥体，直到指定的绝对时间点。如果互斥体在这段时间内变为可用，则锁定并返回 <code>true</code>；如果超时，则返回 <code>false</code>。</li><li><strong>参数</strong>: <code>abs_time</code> 指定的时间点。</li></ul></li></ul><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (tmtx.<span class="hljs-built_in">try_lock_until</span>(std::chrono::steady_clock::<span class="hljs-built_in">now</span>() + std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>))) &#123;    <span class="hljs-comment">// 成功锁定互斥体</span>&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 超时</span>&#125;</code></pre><ul><li><code>void unlock()</code><ul><li><strong>作用</strong>: 解锁互斥体。如果当前线程没有持有该互斥体的锁，将导致未定义行为。</li><li><strong>异常</strong>: 这个函数是 <code>noexcept</code>，不会抛出异常。</li></ul></li></ul><pre><code class="hljs cpp">tmtx.<span class="hljs-built_in">unlock</span>();</code></pre><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span>std::timed_mutex tmtx;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">try_lock_for_example</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (tmtx.<span class="hljs-built_in">try_lock_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>))) &#123;  <span class="hljs-comment">// 尝试锁定，最多等待1秒</span>        std::cout &lt;&lt; <span class="hljs-string">&quot;Lock acquired.&quot;</span> &lt;&lt; std::endl;        tmtx.<span class="hljs-built_in">unlock</span>();    &#125; <span class="hljs-keyword">else</span> &#123;        std::cout &lt;&lt; <span class="hljs-string">&quot;Lock not acquired within timeout.&quot;</span> &lt;&lt; std::endl;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(try_lock_for_example)</span></span>;    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(try_lock_for_example)</span></span>;    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="std-recursive-mutex"><a href="#std-recursive-mutex" class="headerlink" title="std::recursive_mutex"></a><code>std::recursive_mutex</code></h3><p><code>std::recursive_mutex</code> 是一种递归互斥体，允许同一个线程多次锁定同一个互斥体，而不会导致死锁。每次调用 <code>lock</code> 必须有相应的 <code>unlock</code>。</p><h4 id="成员函数-2"><a href="#成员函数-2" class="headerlink" title="成员函数"></a>成员函数</h4><ul><li><code>void lock()</code><ul><li><strong>作用</strong>: 加锁互斥体。如果互斥体已经被其他线程锁定，则调用线程将阻塞，直到互斥体变为可用。相同线程可以多次锁定互斥体。</li></ul></li></ul><pre><code class="hljs cpp">std::recursive_mutex rmtx;rmtx.<span class="hljs-built_in">lock</span>();rmtx.<span class="hljs-built_in">lock</span>();  <span class="hljs-comment">// 可以多次锁定</span></code></pre><ul><li><code>bool try_lock() noexcept</code><ul><li><strong>作用</strong>: 尝试锁定互斥体。如果互斥体没有被其他线程锁定或已经被当前线程锁定，则锁定并返回 <code>true</code>；如果互斥体已经被其他线程锁定，则立即返回 <code>false</code>。</li></ul></li></ul><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (rmtx.<span class="hljs-built_in">try_lock</span>()) &#123;    <span class="hljs-comment">// 成功锁定互斥体</span>&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 互斥体已经被其他线程锁定</span>&#125;</code></pre><ul><li><code>void unlock()</code><ul><li><strong>作用</strong>: 解锁互斥体。如果当前线程多次锁定了互斥体，则每次调用 <code>unlock</code> 只减少一次锁定计数，直到计数归零后才真正解锁。</li></ul></li></ul><pre><code class="hljs cpp">rmtx.<span class="hljs-built_in">unlock</span>();rmtx.<span class="hljs-built_in">unlock</span>();  <span class="hljs-comment">// 必须匹配 lock 的次数</span></code></pre><h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span>std::recursive_mutex rmtx;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recursive_function</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> </span>&#123;    <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;    rmtx.<span class="hljs-built_in">lock</span>();  <span class="hljs-comment">// 可以多次锁定</span>    std::cout &lt;&lt; <span class="hljs-string">&quot;Count: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;    <span class="hljs-built_in">recursive_function</span>(--count);    rmtx.<span class="hljs-built_in">unlock</span>();  <span class="hljs-comment">// 对应解锁</span>&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(recursive_function, <span class="hljs-number">3</span>)</span></span>;    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li><p><strong><code>std::timed_mutex</code></strong>:</p><ul><li>支持基本的锁定和解锁操作。</li><li>支持带超时的锁定操作，如 <code>try_lock_for</code> 和 <code>try_lock_until</code>。</li></ul></li><li><p><strong><code>std::recursive_mutex</code></strong>:</p><ul><li>允许同一线程多次锁定同一互斥体。</li><li>每次锁定必须有相应的解锁，确保正确管理锁计数。</li></ul></li></ul><p>这些工具在多线程编程中提供了灵活和安全的同步机制，帮助开发者有效地控制对共享资源的访问。</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>C++11 提供了多种类型的互斥体和相应的锁管理工具来确保线程安全：</p><ul><li><code>std::mutex</code>：基本的互斥体类型。</li><li><code>std::lock_guard</code>：RAII 风格的互斥体管理。</li><li><code>std::unique_lock</code>：更灵活的锁管理，支持延迟锁定、超时锁定等。</li><li><code>std::timed_mutex</code>：支持带超时的锁定操作。</li><li><code>std::recursive_mutex</code>：允许同一线程多次锁定。</li></ul><p>这些工具帮助程序员更方便和安全地编写多线程程序，确保对共享资源的访问是互斥的，从而避免数据竞争和潜在的并发问题。</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis数据库存取结构体数组数据</title>
      <link href="/2024/03/02/redis/"/>
      <url>/2024/03/02/redis/</url>
      
        <content type="html"><![CDATA[<p><code>hiredis</code> 是一个 C 语言编写的 Redis 客户端库，用于与 Redis 数据库交互。如果你想要通过 hiredis 存储和检索结构体数组的信息，你需要编写相应的 C 代码来处理这些操作。</p><p>下面我将给出一个简单的示例，展示如何使用 hiredis 在 Redis 中存储和检索结构体数组信息。我们将使用 Redis 的 <code>HMSET</code> 和 <code>HGETALL</code> 命令来处理结构体数组。</p><p>首先，让我们定义一个结构体来模拟你的需求：</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">User</span> &#123;</span>    <span class="hljs-type">char</span> *name;    <span class="hljs-type">int</span> age;&#125; User;<span class="hljs-comment">// 函数声明</span><span class="hljs-type">void</span> <span class="hljs-title function_">storeUserInRedis</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> User *user, <span class="hljs-type">long</span> id)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">getUserFromRedis</span><span class="hljs-params">(<span class="hljs-type">long</span> id, <span class="hljs-keyword">struct</span> User *user)</span>;<span class="hljs-type">void</span> <span class="hljs-title function_">printUser</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> User *user)</span>;<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;    <span class="hljs-comment">// 初始化 hiredis 和连接 Redis</span>    redisContext *c = redisConnect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);    <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">NULL</span> || c-&gt;err) &#123;        <span class="hljs-keyword">if</span> (c) &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error: %s\n&quot;</span>, c-&gt;errstr);            redisFree(c);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Connection error: can&#x27;t allocate redis context\n&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">// 创建用户结构体</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">User</span> <span class="hljs-title">fred</span> =</span> &#123;<span class="hljs-string">&quot;Fred&quot;</span>, <span class="hljs-number">25</span>&#125;;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">User</span> <span class="hljs-title">alice</span> =</span> &#123;<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>&#125;;    <span class="hljs-comment">// 生成用户 ID</span>    redisReply *reply = (redisReply *)redisCommand(c, <span class="hljs-string">&quot;INCR id:users&quot;</span>);    <span class="hljs-type">long</span> fred_id = reply-&gt;integer;    freeReplyObject(reply);    <span class="hljs-comment">// 存储用户信息</span>    storeUserInRedis(&amp;fred, fred_id);    <span class="hljs-comment">// 再次生成用户 ID</span>    reply = (redisReply *)redisCommand(c, <span class="hljs-string">&quot;INCR id:users&quot;</span>);    <span class="hljs-type">long</span> alice_id = reply-&gt;integer;    freeReplyObject(reply);    <span class="hljs-comment">// 存储用户信息</span>    storeUserInRedis(&amp;alice, alice_id);    <span class="hljs-comment">// 从 Redis 中获取用户信息</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">User</span> <span class="hljs-title">retrieved_user</span>;</span>    getUserFromRedis(fred_id, &amp;retrieved_user);    printUser(&amp;retrieved_user);    <span class="hljs-comment">// 清理资源</span>    redisFree(c);    <span class="hljs-built_in">free</span>(retrieved_user.name); <span class="hljs-comment">// 释放内存</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">storeUserInRedis</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> User *user, <span class="hljs-type">long</span> id)</span> &#123;    redisReply *reply = (redisReply *)redisCommand(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;HMSET user:%ld name %s age %d&quot;</span>, id, user-&gt;name, user-&gt;age);    freeReplyObject(reply);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">getUserFromRedis</span><span class="hljs-params">(<span class="hljs-type">long</span> id, <span class="hljs-keyword">struct</span> User *user)</span> &#123;    redisReply *reply = (redisReply *)redisCommand(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;HGETALL user:%ld&quot;</span>, id);    <span class="hljs-keyword">if</span> (reply-&gt;type == REDIS_REPLY_ARRAY &amp;&amp; reply-&gt;elements &gt;= <span class="hljs-number">4</span>) &#123;        user-&gt;name = strdup(reply-&gt;element[<span class="hljs-number">1</span>]-&gt;str);        user-&gt;age = atoi(reply-&gt;element[<span class="hljs-number">3</span>]-&gt;str);    &#125;    freeReplyObject(reply);&#125;<span class="hljs-type">void</span> <span class="hljs-title function_">printUser</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> User *user)</span> &#123;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Name: %s, Age: %d\n&quot;</span>, user-&gt;name, user-&gt;age);&#125;</code></pre><p>这个示例程序包含了以下几个部分：</p><ol><li><strong>定义结构体</strong>: <code>struct User</code> 包含用户的姓名和年龄。</li><li><strong>连接 Redis</strong>: 使用 <code>redisConnect</code> 连接到 Redis 服务器。</li><li><strong>生成用户 ID</strong>: 使用 <code>INCR</code> 命令递增 <code>id:users</code> 键的值。</li><li><strong>存储用户信息</strong>: 使用 <code>storeUserInRedis</code> 函数，该函数接受用户结构体和 ID 作为参数，并使用 <code>HMSET</code> 命令存储数据。</li><li><strong>获取用户信息</strong>: 使用 <code>getUserFromRedis</code> 函数，该函数接受用户 ID 和指向用户结构体的指针，使用 <code>HGETALL</code> 命令从 Redis 中获取数据并填充结构体。</li><li><strong>打印用户信息</strong>: 使用 <code>printUser</code> 函数来打印用户信息。</li></ol><p>请注意，在实际应用中你需要确保所有动态分配的内存都被正确释放，例如在 <code>getUserFromRedis</code> 函数中通过 <code>strdup</code> 分配的内存。在上面的示例中，我在 <code>main</code> 函数的最后释放了 <code>retrieved_user.name</code> 的内存。</p><p>这个示例假设你已经在 Redis 中设置了 <code>id:users</code> 键，如果没有的话，你需要先初始化它（例如通过 <code>DEL id:users</code> 和 <code>INCR id:users</code>）。此外，你需要安装 hiredis 库并且在编译时链接它。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>解决spawn-fcgi:child exited with:127报错</title>
      <link href="/2024/02/01/127%E6%8A%A5%E9%94%99/"/>
      <url>/2024/02/01/127%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<p>解决spawn-fcgi:child exited with: 127报错</p><p>spawn-fcgi:child exited with: 127<br>原因：没有找到动态库</p><p>输入指令：ldd 你要运行的程序名<br>来查看缺少的库，如图我确少的是 libfcgi.so.0<br><img src="/images/1722491883237.png"></p><p>解决方案<br>先执行命令，查找所缺文件位置，比如我的（你实际操作时候一定要记住库名换成自己的，-name后面）</p><p><code>find usr/local/lib/ -name &quot;libfcgi.so&quot;</code></p><p><img src="/images/1722492061360.png"></p><p>得到库文件所在路径<code>/usr/local/lib</code></p><p>再执行<code>sudo vi /etc/ld.so.conf</code><br>在文件里添加你得到的库文件路径<code>/usr/local/lib</code>，之后保存退出</p><p><img src="/images/1722492201079.png"></p><p>最后执行<code>sudo ldconfig</code></p><p>再回到原来目录重新编译运行就成功了</p><p><img src="/images/1722492227287.png"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
